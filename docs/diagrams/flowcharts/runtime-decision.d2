# Runtime Selection Decision Flowchart
#
# Top-down flow:
# 1) resolve runtime (override > config default > command default)
# 2) dispatch to selected runtime path
# 3) execute or fail with actionable runtime errors
#
# Source: docs/architecture/flowchart-runtime-selection.md

vars: {
  d2-config: {
    layout-engine: tala
  }
}

direction: down

Start: Start (Command Request) {
  shape: oval
  style.fill: "#E8F5E9"
}

ResolveRuntime: Resolve runtime using precedence {
  style.fill: "#BBDEFB"
}

Start -> ResolveRuntime

# ------------------------------------------------------------------------------
# Runtime precedence (clear top section)
# ------------------------------------------------------------------------------

HasOverride: --ivk-runtime provided? {
  shape: diamond
  style.fill: "#FFF3E0"
}
OverrideAllowed: Override allowed for command/platform? {
  shape: diamond
  style.fill: "#FFF3E0"
}
UseOverride: Use CLI override {
  style.fill: "#C8E6C9"
}

HasConfigDefault: config.default_runtime set? {
  shape: diamond
  style.fill: "#FFF3E0"
}
ConfigAllowed: Config default allowed for command/platform? {
  shape: diamond
  style.fill: "#FFF3E0"
}
UseConfigDefault: Use compatible config default {
  style.fill: "#C8E6C9"
}

UseCommandDefault: Use command default runtime {
  style.fill: "#C8E6C9"
}

ErrOverride: Error: invalid runtime override {
  shape: oval
  style.fill: "#FFCDD2"
}

ResolveRuntime -> HasOverride
HasOverride -> OverrideAllowed: Yes
HasOverride -> HasConfigDefault: No
OverrideAllowed -> UseOverride: Yes
OverrideAllowed -> ErrOverride: No
HasConfigDefault -> ConfigAllowed: Yes
HasConfigDefault -> UseCommandDefault: No
ConfigAllowed -> UseConfigDefault: Yes
ConfigAllowed -> UseCommandDefault: No

# ------------------------------------------------------------------------------
# SSH lifecycle (CommandService responsibility, before dispatch)
# ------------------------------------------------------------------------------

SSHNeeded: enable_host_ssh = true? {
  shape: diamond
  style.fill: "#FFF3E0"
}
EnsureSSH: CommandService starts SSH server {
  style.fill: "#BBDEFB"
}

UseOverride -> SSHNeeded
UseConfigDefault -> SSHNeeded
UseCommandDefault -> SSHNeeded

SSHNeeded -> EnsureSSH: Yes
SSHNeeded -> Dispatch: No
EnsureSSH -> Dispatch

Dispatch: Dispatch by selected runtime {
  shape: diamond
  style.fill: "#FFF3E0"
}

# ------------------------------------------------------------------------------
# Native path
# ------------------------------------------------------------------------------

NativeAvailable: Native shell available? {
  shape: diamond
  style.fill: "#FFF3E0"
}
NativeRun: Run with native runtime {
  style.fill: "#C8E6C9"
}
ErrNative: Error: native runtime unavailable {
  shape: oval
  style.fill: "#FFCDD2"
}

Dispatch -> NativeAvailable: native
NativeAvailable -> NativeRun: Yes
NativeAvailable -> ErrNative: No

# ------------------------------------------------------------------------------
# Virtual path
# ------------------------------------------------------------------------------

VirtualRun: Run with virtual runtime (mvdan/sh) {
  style.fill: "#C8E6C9"
}

Dispatch -> VirtualRun: virtual

# ------------------------------------------------------------------------------
# Container path
# ------------------------------------------------------------------------------

ContainerAvailable: Container runtime available? {
  shape: diamond
  style.fill: "#FFF3E0"
}
ErrContainer: Error: container runtime unavailable {
  shape: oval
  style.fill: "#FFCDD2"
}
PrepareContainer: Prepare container execution {
  style.fill: "#BBDEFB"
}

Dispatch -> ContainerAvailable: container
ContainerAvailable -> PrepareContainer: Yes
ContainerAvailable -> ErrContainer: No

ValidateImage: Supported image? {
  shape: diamond
  style.fill: "#FFF3E0"
}
ErrUnsupportedImage: Error: unsupported image\n(Alpine/Windows) {
  shape: oval
  style.fill: "#FFCDD2"
}

PrepareContainer -> ValidateImage

ValidateImage -> ErrUnsupportedImage: No

ImageSource: Image source? {
  shape: diamond
  style.fill: "#FFF3E0"
}
ImageExists: Image exists locally? {
  shape: diamond
  style.fill: "#FFF3E0"
}
BuildImage: Build from Containerfile
PullImage: Pull image from registry
UseImage: Use selected image
AddLayer: Add ephemeral invowk layer
InjectSSH: Inject SSH tokens + env vars\n(if SSH server active) {
  style.fill: "#BBDEFB"
}
ContainerRun: Run in container {
  style.fill: "#C8E6C9"
}

ValidateImage -> ImageSource: Yes
ImageSource -> ImageExists: image
ImageSource -> BuildImage: containerfile
ImageExists -> UseImage: Yes
ImageExists -> PullImage: No
BuildImage -> UseImage
PullImage -> UseImage
UseImage -> AddLayer
AddLayer -> InjectSSH
InjectSSH -> ContainerRun

# ------------------------------------------------------------------------------
# Terminal success
# ------------------------------------------------------------------------------

Execute: Execute command {
  shape: oval
  style.fill: "#E8F5E9"
}

NativeRun -> Execute
VirtualRun -> Execute
ContainerRun -> Execute
