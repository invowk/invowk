# SPDX-License-Identifier: MPL-2.0
#
# goplint exceptions — intentional primitive type usage
#
# This file documents every known location where bare primitive types are
# intentionally retained. Each entry includes a reason explaining why the
# DDD Value Type pattern was not applied.
#
# Pattern syntax:
#   Type.Field           — exact struct field match
#   Function.param       — function param by name
#   Function.return.N    — return type by position (0-indexed)
#   *.Field              — any type, specific field name
#   Package.Type.*       — all fields on a type
#
# To add a new exception, append an [[exceptions]] entry with both
# pattern and reason fields.

[settings]
# Types that are never flagged regardless of context.
skip_types = ["bool", "error", "context.Context", "any"]

# File paths containing these substrings are excluded entirely.
exclude_paths = [
    "specs/",             # Specification/contract files, not production code
    "internal/testutil/", # Test utilities, not domain types
]

# =============================================================================
# Exec / OS Boundary
# =============================================================================
# Values passed directly to exec.CommandContext, os.Stat, filepath.Join,
# or similar stdlib calls where named types would add more casts than
# they remove.

[[exceptions]]
pattern = "ExecuteRequest.Name"
reason = "Cobra + interface boundary"

[[exceptions]]
pattern = "ExecuteRequest.Args"
reason = "exec boundary (positional args passed to shell)"

[[exceptions]]
pattern = "ExecuteRequest.EnvVars"
reason = "exec/OS boundary (KEY=VALUE env pairs)"

[[exceptions]]
pattern = "ExecuteRequest.UserEnv"
reason = "exec/OS boundary (captured host environment)"

[[exceptions]]
pattern = "ExecutionContext.PositionalArgs"
reason = "exec boundary (shell positional parameters)"

[[exceptions]]
pattern = "EnvContext.ExtraEnv"
reason = "exec/OS boundary"

[[exceptions]]
pattern = "EnvContext.RuntimeEnvVars"
reason = "exec/OS boundary"

[[exceptions]]
pattern = "BuildExecutionContextOptions.Args"
reason = "exec/OS boundary"

[[exceptions]]
pattern = "BuildExecutionContextOptions.EnvVars"
reason = "exec/OS boundary"

[[exceptions]]
pattern = "BaseCLIEngine.cmdEnvOverrides"
reason = "exec/OS boundary"

[[exceptions]]
pattern = "BaseCLIEngine.name"
reason = "display label"

[[exceptions]]
pattern = "containerExecPrep.shellCmd"
reason = "exec boundary"

[[exceptions]]
pattern = "containerExecPrep.env"
reason = "exec boundary"

[[exceptions]]
pattern = "SpinCommandOptions.Command"
reason = "exec command slice"

[[exceptions]]
pattern = "ShebangInfo.Args"
reason = "exec boundary"

[[exceptions]]
pattern = "ShebangInfo.Interpreter"
reason = "full paths like /bin/bash; BinaryName rejects paths"

[[exceptions]]
pattern = "ResolveDockerfilePath.*"
reason = "exec boundary — params/return passed to filepath operations"

# =============================================================================
# Display-Only Fields
# =============================================================================
# Fields whose values are only rendered for human consumption, with no
# programmatic interpretation.

[[exceptions]]
pattern = "ValidationIssue.Message"
reason = "display-only"

[[exceptions]]
pattern = "ValidationIssue.Path"
reason = "display-only"

[[exceptions]]
pattern = "ValidationError.Field"
reason = "display-only field path label"

[[exceptions]]
pattern = "InitDiagnostic.Message"
reason = "display-only diagnostic message"

[[exceptions]]
pattern = "CapabilityError.Message"
reason = "display-only error detail"

[[exceptions]]
pattern = "EngineNotAvailableError.Reason"
reason = "display-only error detail"

[[exceptions]]
pattern = "Result.Output"
reason = "raw captured stdout"

[[exceptions]]
pattern = "Result.ErrOutput"
reason = "raw captured stderr"

[[exceptions]]
pattern = "SpinResult.Stdout"
reason = "raw captured output"

[[exceptions]]
pattern = "SpinResult.Stderr"
reason = "raw captured output"

[[exceptions]]
pattern = "ModuleCollisionError.FirstSource"
reason = "composite display string"

[[exceptions]]
pattern = "ModuleCollisionError.SecondSource"
reason = "composite display string"

# =============================================================================
# Import Cycle Prevention
# =============================================================================
# Using typed fields would require importing a package that creates a
# circular dependency.

[[exceptions]]
pattern = "tuiserver.*.*"
reason = "import cycle: tui->tuiserver; JSON wire format for all protocol types"

[[exceptions]]
pattern = "tuiserver.*.*.*"
reason = "import cycle: tui->tuiserver; method params"

[[exceptions]]
pattern = "tuiserver.*.*.*.*"
reason = "import cycle: tui->tuiserver; method returns"

# =============================================================================
# Free-Form User Input
# =============================================================================
# Values from user input or external sources with no fixed domain type.

[[exceptions]]
pattern = "*.DefaultValue"
reason = "free-form flag/argument default"

[[exceptions]]
pattern = "ArgumentValidationError.InvalidValue"
reason = "free-form user input / Cobra boundary"

[[exceptions]]
pattern = "ArgumentValidationError.ProvidedArgs"
reason = "free-form user input / Cobra boundary"

[[exceptions]]
pattern = "AmbiguousIdentifierError.Identifier"
reason = "free-form user input"

[[exceptions]]
pattern = "cmdFlagValues.runtimeOverride"
reason = "Cobra flag binding"

[[exceptions]]
pattern = "cmdFlagValues.fromSource"
reason = "Cobra flag binding"

# =============================================================================
# Wire / Interface / External Boundaries
# =============================================================================
# Values crossing serialization, framework, or external contract boundaries.

[[exceptions]]
pattern = "EnvConfig.Vars"
reason = "map key breaks maps.Copy compatibility"

[[exceptions]]
pattern = "Token.CommandID"
reason = "composite string"

[[exceptions]]
pattern = "ConnectionInfo.User"
reason = "always 'invowk'"

[[exceptions]]
pattern = "Server.addr"
reason = "composite 'host:port'"

[[exceptions]]
pattern = "TagInfo.Name"
reason = "go-git pass-through"

[[exceptions]]
pattern = "UnpackOptions.Source"
reason = "mixed path/URL"

[[exceptions]]
pattern = "FieldPath.EnvVar.key"
reason = "EnvConfig.Vars map key is intentionally string"

[[exceptions]]
pattern = "FieldPath.Field.name"
reason = "generic field name adder"

# =============================================================================
# Internal Parse-Tree / Domain-Specific Fields
# =============================================================================

[[exceptions]]
pattern = "Version.Prerelease"
reason = "internal parse-tree field"

[[exceptions]]
pattern = "Version.Original"
reason = "internal parse-tree field"

[[exceptions]]
pattern = "Constraint.Original"
reason = "internal parse-tree field"

[[exceptions]]
pattern = "SemverResolver.Resolve.constraintStr"
reason = "constraint expression, not a version tag"

[[exceptions]]
pattern = "configDirFrom.goos"
reason = "runtime.GOOS boundary, no typed alternative"

[[exceptions]]
pattern = "moduleError.op"
reason = "unexported display label"

[[exceptions]]
pattern = "checkCommandDependenciesExist.currentModule"
reason = "empty string = no module; ModuleID rejects empty"

# =============================================================================
# Test-Only Fields
# =============================================================================

[[exceptions]]
pattern = "provision.Config.TagSuffix"
reason = "test-only"

# =============================================================================
# TUI Display Labels
# =============================================================================
# All TUI option Title/Description/Placeholder etc. fields are display
# labels with no domain semantics beyond rendering.

[[exceptions]]
pattern = "*.Title"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Description"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Placeholder"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Value"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Prompt"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Affirmative"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Negative"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Cursor"
reason = "TUI display label"

[[exceptions]]
pattern = "*.Separator"
reason = "TUI display label"

[[exceptions]]
pattern = "TableOptions.Rows"
reason = "display data ([][]string)"

[[exceptions]]
pattern = "FilterOptions.Options"
reason = "display data ([]string)"

[[exceptions]]
pattern = "ChooseStringOptions.Options"
reason = "display data ([]string)"

[[exceptions]]
pattern = "FormatOptions.Content"
reason = "rendering input"

[[exceptions]]
pattern = "FormatOptions.Language"
reason = "external open-ended enum"

[[exceptions]]
pattern = "FormatOptions.GlamourTheme"
reason = "external open-ended enum"

# =============================================================================
# Rendering / Output
# =============================================================================

[[exceptions]]
pattern = "VendorResult.Pruned"
reason = "directory base names with .invowkmod suffix"

# =============================================================================
# Unexported Trivial Fields (bulk exceptions)
# =============================================================================
# Unexported fields in structs with many call sites where casts would
# dominate with no external benefit.

[[exceptions]]
pattern = "uroot.FlagInfo.Name"
reason = "constant string literals across 25 files, near-zero risk"

[[exceptions]]
pattern = "uroot.FlagInfo.ShortName"
reason = "constant string literals across 25 files"

[[exceptions]]
pattern = "uroot.*.name"
reason = "display-only labels in 12+ unexported structs"

[[exceptions]]
pattern = "watch.Watcher.baseDir"
reason = "unexported, 8+ filepath.* casts for no external benefit"

# =============================================================================
# Interface Contract Implementations
# =============================================================================
# Method signatures dictated by external interfaces that cannot use named types.

[[exceptions]]
pattern = "uroot.*.Run.args"
reason = "uroot Command interface contract: Run(ctx, args []string)"

[[exceptions]]
pattern = "uroot.*.Name.return.0"
reason = "uroot Command interface contract: Name() string"

[[exceptions]]
pattern = "*.FilterValue.return.0"
reason = "bubbles list.Item interface: FilterValue() string"

[[exceptions]]
pattern = "*.Height.return.0"
reason = "bubbles list.ItemDelegate interface: Height() int"

[[exceptions]]
pattern = "*.Spacing.return.0"
reason = "bubbles list.ItemDelegate interface: Spacing() int"

# =============================================================================
# Error Detail Fields
# =============================================================================
# Display-only reason/message fields in InvalidXxxError structs, same semantic
# category as already-excepted CapabilityError.Message.
# Scope: 10 error structs (InvalidSubdirectoryPathError, InvalidGlobPatternError,
# InvalidVolumeMountSpecError, InvalidRegexPatternError, InvalidPortMappingSpecError,
# InvalidFlagNameError, InvalidDurationStringError, InvalidBinaryNameError,
# InvalidArgumentNameError, EngineNotAvailableError). If a non-error struct
# adds a Reason field with domain semantics, add it as a DDD type instead.

[[exceptions]]
pattern = "*.Reason"
reason = "display-only error detail in InvalidXxxError structs"

# =============================================================================
# Set-Tracking Idiom (map[*]bool)
# =============================================================================
# Bool is exempt as a standalone type, but map keys in set-tracking patterns
# are idiomatic Go and carry no domain semantics.

[[exceptions]]
pattern = "*.selected"
reason = "map[int]bool selection set (bool value carries no domain meaning)"

[[exceptions]]
pattern = "*.expectedDirs"
reason = "map[string]bool directory-name set"

# =============================================================================
# Container / Runtime Exec Boundary (additional)
# =============================================================================
# Container-specific exec boundary fields not covered by existing patterns.

[[exceptions]]
pattern = "RunOptions.Command"
reason = "exec boundary (container command slice)"

[[exceptions]]
pattern = "RunOptions.Env"
reason = "exec/OS boundary (container env map)"

[[exceptions]]
pattern = "BuildOptions.BuildArgs"
reason = "exec boundary (docker --build-arg map)"

[[exceptions]]
pattern = "envInheritConfig.*"
reason = "exec/OS boundary (env var name lists for filtering)"

# =============================================================================
# MEMORY.md Gap Fixes
# =============================================================================

[[exceptions]]
pattern = "*.FlagValues"
reason = "map value is free-form user input; key is already typed FlagName"

[[exceptions]]
pattern = "*.message"
reason = "display-only diagnostic/error message (constructor params)"

# =============================================================================
# TUI Rendering Internals
# =============================================================================
# Low-level ANSI terminal rendering functions that operate on raw terminal
# output — no domain semantics, just string/int manipulation for rendering.

[[exceptions]]
pattern = "tui.hexToANSIBackground.*"
reason = "ANSI rendering internal — operates on raw terminal output"

[[exceptions]]
pattern = "tui.sanitizeModalBackground.*"
reason = "ANSI rendering internal"

[[exceptions]]
pattern = "tui.compositeLineANSI.*"
reason = "ANSI rendering internal"

[[exceptions]]
pattern = "tui.getANSISuffix.*"
reason = "ANSI rendering internal"

[[exceptions]]
pattern = "tui.padLineToWidth.*"
reason = "ANSI rendering internal"

[[exceptions]]
pattern = "tui.RenderOverlay.*"
reason = "rendering output composition"

# =============================================================================
# Remaining Intentional int Exceptions
# =============================================================================

[[exceptions]]
pattern = "TableSelectionResult.SelectedIndex"
reason = "array index"

[[exceptions]]
pattern = "ArgumentValidationError.MinArgs"
reason = "argument count value"

[[exceptions]]
pattern = "ArgumentValidationError.MaxArgs"
reason = "argument count value"

[[exceptions]]
pattern = "WriteOptions.CharLimit"
reason = "count for huh boundary"

[[exceptions]]
pattern = "InputOptions.CharLimit"
reason = "count for huh boundary"

[[exceptions]]
pattern = "ChooseStringOptions.Limit"
reason = "count value"

[[exceptions]]
pattern = "MultiChooseOptions.Limit"
reason = "count value"

[[exceptions]]
pattern = "FilterOptions.Limit"
reason = "count value"

# =============================================================================
# Remaining Intentional []int Exceptions
# =============================================================================

[[exceptions]]
pattern = "Style.Padding"
reason = "lipgloss CSS-shorthand passthrough; import cycle with tuiserver"

[[exceptions]]
pattern = "Style.Margin"
reason = "lipgloss CSS-shorthand passthrough; import cycle with tuiserver"

# =============================================================================
# Mutable-by-Design Structs (DDD Entities / Post-Construction Mutation)
# =============================================================================
# These structs have constructors but are NOT Value Types — they are Entities
# or DTOs with intentional post-construction mutation. Six structs now have
# //goplint:mutable directives on their type declarations:
#   DiscoveredCommandSet, ExecutionContext, DefaultEnvBuilder,
#   App, CommandScope, LockFile.

[[exceptions]]
pattern = "invowkfile.ValidationError.immutability"
reason = "70+ struct literal sites across validation_structure_*.go; separate PR"

# --- Service Objects: struct-validate exceptions ---
# Service objects, registries, builders, and state machines have runtime-dynamic
# validity (engine availability, post-construction population, lifecycle state).
# Validate() is not meaningful for these — construction guarantees internal consistency.

# Service objects — container engines
[[exceptions]]
pattern = "container.BaseCLIEngine.struct-validate"
reason = "service object; binaryPath='' valid for 'not found' sentinel"

[[exceptions]]
pattern = "container.DockerEngine.struct-validate"
reason = "service object; wraps BaseCLIEngine"

[[exceptions]]
pattern = "container.PodmanEngine.struct-validate"
reason = "service object; wraps BaseCLIEngine"

[[exceptions]]
pattern = "container.SandboxAwareEngine.struct-validate"
reason = "service decorator; used via Engine interface"

# Service objects — servers, provisioners, runtimes
[[exceptions]]
pattern = "serverbase.Base.struct-validate"
reason = "lifecycle state machine; validity is runtime state"

[[exceptions]]
pattern = "provision.LayerProvisioner.struct-validate"
reason = "service object; fields always non-nil from constructor"

[[exceptions]]
pattern = "runtime.ContainerRuntime.struct-validate"
reason = "stateful service with mutex/atomic; single-instance"

[[exceptions]]
pattern = "runtime.NativeRuntime.struct-validate"
reason = "service object; shell='' valid for auto-detect"

[[exceptions]]
pattern = "runtime.VirtualRuntime.struct-validate"
reason = "service object; invariants enforced by constructor"

# Service objects — module resolution
[[exceptions]]
pattern = "invowkmod.Resolver.struct-validate"
reason = "stateful service with mutex; constructor returns error"

[[exceptions]]
pattern = "invowkmod.GitFetcher.struct-validate"
reason = "service object; empty cacheDir valid for default"

# Zero-field stateless services
[[exceptions]]
pattern = "invowkfile.StructureValidator.struct-validate"
reason = "zero-field struct; no invariants"

[[exceptions]]
pattern = "invowkmod.SemverResolver.struct-validate"
reason = "zero-field struct; no invariants"

# Mutable entities (already have .immutability exceptions)
[[exceptions]]
pattern = "invowk.App.struct-validate"
reason = "composition root; validity is runtime-dynamic"

[[exceptions]]
pattern = "discovery.DiscoveredCommandSet.struct-validate"
reason = "maps populated post-construction"

[[exceptions]]
pattern = "runtime.ExecutionContext.struct-validate"
reason = "13 fields set post-construction; DDD Entity"

[[exceptions]]
pattern = "runtime.DefaultEnvBuilder.struct-validate"
reason = "strategy; nil Environ valid (os.Environ fallback)"

[[exceptions]]
pattern = "invowkmod.CommandScope.struct-validate"
reason = "has AddDirectDep() mutation; DDD Entity"

[[exceptions]]
pattern = "invowkmod.LockFile.struct-validate"
reason = "Modules map mutated by resolver; DDD Entity"

# Registries (post-construction population)
[[exceptions]]
pattern = "runtime.Registry.struct-validate"
reason = "runtime registration container; populated via Register()"

[[exceptions]]
pattern = "uroot.Registry.struct-validate"
reason = "command registration container; populated via Register()"

# Fluent builders (mutable by design)
[[exceptions]]
pattern = "issue.ErrorContext.struct-validate"
reason = "fluent builder; accumulates state before BuildError()"

[[exceptions]]
pattern = "invowkfile.FieldPath.struct-validate"
reason = "fluent builder; mutated by Root()/Command()/Flag()"

# Composite pattern
[[exceptions]]
pattern = "invowkfile.CompositeValidator.struct-validate"
reason = "composite pattern; has Add() mutation method"

# =============================================================================
# Missing Constructor Exceptions (DTOs / CUE-parsed / Builders / Results)
# =============================================================================
# These structs are DTOs, CUE-parsed data, fluent builders, or result types
# that are intentionally constructed via struct literals rather than constructors.
# 4G audit (2026-02-28): All 15 patterns are ACTIVE (106 exported structs across
# these packages lack constructors by design). The --audit-exceptions --global
# tool reported them as "stale" because --check-constructors was not active in
# the analysis run it used. With --check-all, all 15 patterns are required.

# Per-package bulk patterns — all flagged types in these packages are DTOs
[[exceptions]]
pattern = "invowkfile.*.constructor"
reason = "CUE-parsed DTOs; constructed via CUE decode or struct literals"

[[exceptions]]
pattern = "invowkmod.*.constructor"
reason = "DTOs and data types; constructed via struct literals"

[[exceptions]]
pattern = "config.*.constructor"
reason = "config DTOs; populated by Viper mapstructure"

[[exceptions]]
pattern = "runtime.*.constructor"
reason = "runtime DTOs/options; constructed via struct literals"

[[exceptions]]
pattern = "container.*.constructor"
reason = "container DTOs/options; constructed via struct literals"

[[exceptions]]
pattern = "discovery.*.constructor"
reason = "discovery DTOs/results; constructed via struct literals"

[[exceptions]]
pattern = "sshserver.*.constructor"
reason = "SSH server DTOs/config; constructed via struct literals"

[[exceptions]]
pattern = "provision.*.constructor"
reason = "provisioning DTOs; constructed via struct literals"

[[exceptions]]
pattern = "uroot.*.constructor"
reason = "u-root utility types; constant struct literals"

[[exceptions]]
pattern = "watch.*.constructor"
reason = "watch DTOs; constructed via struct literals"

[[exceptions]]
pattern = "cueutil.*.constructor"
reason = "CUE utility result types; constructed via struct literals"

[[exceptions]]
pattern = "execute.*.constructor"
reason = "execution orchestration DTOs; constructed via struct literals"

[[exceptions]]
pattern = "invowk.*.constructor"
reason = "CLI entry point DTOs; constructed via struct literals"

[[exceptions]]
pattern = "issue.*.constructor"
reason = "error context types; constructed via struct literals"

[[exceptions]]
pattern = "tui.*.constructor"
reason = "TUI builders, options, results, and config; fluent API types"

# =============================================================================
# Missing Functional Options Exceptions
# =============================================================================
# Structs where functional options are not appropriate: required params,
# high literal-site count, or required dependencies (not optional config).

[[exceptions]]
pattern = "invowkfile.ModuleMetadata.func-options"
reason = "4 required params for immutable value type"

[[exceptions]]
pattern = "invowkfile.ValidationError.func-options"
reason = "4 required params; 70+ struct literal construction sites"

[[exceptions]]
pattern = "runtime.ContainerRuntime.func-options"
reason = "cfg, engine, sshServer, provisioner are required deps, not optional"

[[exceptions]]
pattern = "discovery.Discovery.func-options"
reason = "cfg is a required param, not optional"

# =============================================================================
# Primitive Bulk Exceptions — TUI Internal Model State
# =============================================================================
# Unexported TUI model structs hold transient UI state (cursor position,
# selection indices, viewport offsets). No domain semantics.

# =============================================================================
# Primitive Bulk Exceptions — TUI Builder Method Params
# =============================================================================
# Fluent builder methods accept display labels, indices, and config values.
# 4-segment pattern: tui.XxxBuilder.MethodName.param

[[exceptions]]
pattern = "tui.*Builder.*.*"
reason = "fluent builder display label / config param"

# =============================================================================
# Primitive Bulk Exceptions — TUI Convenience Functions
# =============================================================================
# Top-level TUI convenience wrappers accept display data (options, titles)
# and return selection/render results.

[[exceptions]]
pattern = "tui.ChooseStrings.*"
reason = "TUI convenience wrapper — display data params"

[[exceptions]]
pattern = "tui.MultiChooseStrings.*"
reason = "TUI convenience wrapper — display data params"

[[exceptions]]
pattern = "tui.FilterStrings.*"
reason = "TUI convenience wrapper — display data params"

[[exceptions]]
pattern = "tui.ExactMatch.*"
reason = "TUI convenience wrapper — display data params"

[[exceptions]]
pattern = "tui.TableFromCSV.*"
reason = "TUI convenience wrapper — display data params"

[[exceptions]]
pattern = "tui.SpinWithCommand.*"
reason = "exec boundary — command + args passed to shell"

[[exceptions]]
pattern = "tui.ParseSpinnerType.*"
reason = "TUI convenience wrapper — string-to-enum parse"

[[exceptions]]
pattern = "tui.stripOSCSequences.*"
reason = "ANSI rendering internal"

[[exceptions]]
pattern = "tui.getTerminalSize.return.*"
reason = "terminal size return — OS boundary"

[[exceptions]]
pattern = "tui.getTerminalSizeFromFd.*"
reason = "terminal size — OS boundary (fd + returns)"

[[exceptions]]
pattern = "tui.getTerminalSizeFromFd.return.*"
reason = "terminal size return — OS boundary"

[[exceptions]]
pattern = "tui.multiChooseDelegate.Render.index"
reason = "bubbletea delegate interface — index param"

# TUI convenience function returns (display/selection text)
[[exceptions]]
pattern = "tui.ChooseStrings.return.*"
reason = "TUI convenience return — selected display text"

[[exceptions]]
pattern = "tui.ChooseStringsWithModel.return.*"
reason = "TUI convenience return — selected display text"

[[exceptions]]
pattern = "tui.MultiChooseStrings.return.*"
reason = "TUI convenience return — selected display text"

[[exceptions]]
pattern = "tui.FilterStrings.return.*"
reason = "TUI convenience return — selected display text"

[[exceptions]]
pattern = "tui.ExactMatch.return.*"
reason = "TUI convenience return — matched display text"

[[exceptions]]
pattern = "tui.File.return.*"
reason = "TUI convenience return — selected file path display text"

[[exceptions]]
pattern = "tui.Filter.return.*"
reason = "TUI convenience return — selected display text"

[[exceptions]]
pattern = "tui.Input.return.*"
reason = "TUI convenience return — user input display text"

[[exceptions]]
pattern = "tui.Write.return.*"
reason = "TUI convenience return — user input display text"

[[exceptions]]
pattern = "tui.Table.return.*"
reason = "TUI convenience return — selected row/index"

[[exceptions]]
pattern = "tui.Format.return.*"
reason = "TUI rendering return — formatted display text"

[[exceptions]]
pattern = "tui.formatMarkdown.return.*"
reason = "TUI rendering return"

[[exceptions]]
pattern = "tui.formatCode.return.*"
reason = "TUI rendering return"

[[exceptions]]
pattern = "tui.formatEmoji.return.*"
reason = "TUI rendering return"

[[exceptions]]
pattern = "tui.SpinnerTypeNames.return.*"
reason = "TUI convenience return — enum display names"

[[exceptions]]
pattern = "tui.Style.Apply.*"
reason = "rendering method — accepts/returns display text"

[[exceptions]]
pattern = "tui.Style.Apply.return.*"
reason = "rendering method return"

# TUI unexported item interface returns (already excepted for FilterValue/View)
[[exceptions]]
pattern = "tui.chooseItem.Description.return.*"
reason = "bubbles list.Item interface"

[[exceptions]]
pattern = "tui.chooseItem.Title.return.*"
reason = "bubbles list.Item interface"

[[exceptions]]
pattern = "tui.filterItem.Description.return.*"
reason = "bubbles list.Item interface"

[[exceptions]]
pattern = "tui.filterItem.Title.return.*"
reason = "bubbles list.Item interface"

# =============================================================================
# Primitive Bulk Exceptions — u-root POSIX Utilities
# =============================================================================
# u-root commands implement POSIX utilities operating on raw text/byte
# streams. All params/returns/fields are POSIX domain, not Invowk domain.
# These 3 patterns at different segment depths cover all findings in the
# package. The individual uroot entries above (Name, Description, Run.args,
# etc.) are subsumed by these broad patterns but kept for documentation.

[[exceptions]]
pattern = "uroot.*.*"
reason = "u-root POSIX utility internals (struct fields + function params)"

[[exceptions]]
pattern = "uroot.*.*.*"
reason = "u-root POSIX utility internals (method params + function returns)"

[[exceptions]]
pattern = "uroot.*.*.*.*"
reason = "u-root POSIX utility internals (method returns)"

# =============================================================================
# Primitive Bulk Exceptions — issue Package
# =============================================================================
# The issue package provides error context building and rendering.
# All fields/params/returns are display-only operation/resource/suggestion strings.

[[exceptions]]
pattern = "issue.*.*"
reason = "error context display fields + function params"

[[exceptions]]
pattern = "issue.*.*.*"
reason = "error context method params"

[[exceptions]]
pattern = "issue.*.*.return.*"
reason = "error context method returns (formatted display text)"

# =============================================================================
# Primitive Bulk Exceptions — Cobra Handler Args
# =============================================================================
# All invowk.run* functions receive Cobra []string args. These are the raw
# positional arguments from the CLI framework, not domain-typed values.

[[exceptions]]
pattern = "invowk.run*.args"
reason = "Cobra []string positional args"

[[exceptions]]
pattern = "invowk.checkAmbiguousCommand.args"
reason = "Cobra []string positional args"

[[exceptions]]
pattern = "invowk.ParseSourceFilter.args"
reason = "Cobra []string positional args"

# =============================================================================
# Primitive Exceptions — FieldPath Internals
# =============================================================================
# FieldPath is a fluent builder for validation error paths. All index params
# and the internal parts slice are positional/structural, not domain-typed.

[[exceptions]]
pattern = "invowkfile.FieldPath.*"
reason = "FieldPath struct field (internal parts slice)"

[[exceptions]]
pattern = "invowkfile.FieldPath.*.*"
reason = "FieldPath method index/name params"

[[exceptions]]
pattern = "invowkfile.itoa.*"
reason = "FieldPath utility — int-to-string for path building"

[[exceptions]]
pattern = "invowkfile.itoa.return.*"
reason = "FieldPath utility return"

[[exceptions]]
pattern = "invowkfile.ValidationErrors.*.return.*"
reason = "error/warning count returns (display-only)"

# =============================================================================
# Primitive Exceptions — invowkfile Generate Indent
# =============================================================================
# CUE code generation indentation level params — structural, not domain.

[[exceptions]]
pattern = "invowkfile.generate*.indent"
reason = "CUE codegen indentation level"

# =============================================================================
# Primitive Exceptions — Semver Components
# =============================================================================
# Version struct integer fields are parse-tree components, not domain types.

[[exceptions]]
pattern = "invowkmod.Version.Major"
reason = "semver parse-tree component"

[[exceptions]]
pattern = "invowkmod.Version.Minor"
reason = "semver parse-tree component"

[[exceptions]]
pattern = "invowkmod.Version.Patch"
reason = "semver parse-tree component"

[[exceptions]]
pattern = "invowkmod.Version.Compare.return.*"
reason = "comparison result (-1/0/1)"

# =============================================================================
# Primitive Exceptions — invowkmod CUE Text Manipulation
# =============================================================================
# Internal CUE text parsing/formatting functions that manipulate raw CUE source.

[[exceptions]]
pattern = "invowkmod.entryBounds.*"
reason = "CUE text line range struct"

[[exceptions]]
pattern = "invowkmod.findRequiresBlock.*"
reason = "CUE text block-finding internal"

[[exceptions]]
pattern = "invowkmod.findRequiresBlock.return.*"
reason = "CUE text block-finding return"

[[exceptions]]
pattern = "invowkmod.findEntryBounds.*"
reason = "CUE text entry bounds internal"

[[exceptions]]
pattern = "invowkmod.parseRequiresEntryFields.*"
reason = "CUE text field-parsing internal"

[[exceptions]]
pattern = "invowkmod.parseRequiresEntryFields.return.*"
reason = "CUE text field-parsing return"

[[exceptions]]
pattern = "invowkmod.formatRequiresEntry.return.*"
reason = "CUE text formatting return"

[[exceptions]]
pattern = "invowkmod.parseStringValue.*"
reason = "CUE text value-parsing internal"

[[exceptions]]
pattern = "invowkmod.parseStringValue.return.*"
reason = "CUE text value-parsing return"

[[exceptions]]
pattern = "invowkmod.parseModuleKey.*"
reason = "CUE text key-parsing internal"

[[exceptions]]
pattern = "invowkmod.parseLockFileCUE.content"
reason = "raw CUE source text input"

# =============================================================================
# Primitive Exceptions — cmd/invowk Cobra / Display / Config Boundary
# =============================================================================
# Functions at the CLI boundary that accept/return display text, config paths,
# or pass values to Cobra/shell/config subsystems.

[[exceptions]]
pattern = "invowk.shellEscapeSingleQuote.*"
reason = "shell escaping — raw text manipulation"

[[exceptions]]
pattern = "invowk.shellEscapeSingleQuote.return.*"
reason = "shell escaping return"

[[exceptions]]
pattern = "invowk.validateCustomCheckOutput.outputStr"
reason = "raw command output text"

[[exceptions]]
pattern = "invowk.captureUserEnv.return.*"
reason = "raw env map capture — exec/OS boundary"

[[exceptions]]
pattern = "invowk.setConfigValue.*"
reason = "Viper config key/value — framework boundary"

[[exceptions]]
pattern = "invowk.buildVirtualEnv.*"
reason = "env var construction — exec/OS boundary"

[[exceptions]]
pattern = "invowk.buildVirtualEnv.return.*"
reason = "env map return — exec/OS boundary"

[[exceptions]]
pattern = "invowk.rootFlagValues.configPath"
reason = "Cobra flag binding (resolved later to FilesystemPath)"

[[exceptions]]
pattern = "invowk.discoveryRequestCache.lookups"
reason = "cache map key — internal optimization"

[[exceptions]]
pattern = "invowk.resolvedDefinitions.flagValues"
reason = "Cobra flag value map — framework boundary"

[[exceptions]]
pattern = "invowk.newContainerValidationContext.script"
reason = "raw script content for validation"

[[exceptions]]
pattern = "invowk.checkTransientExitCode.label"
reason = "display label for error messages"

[[exceptions]]
pattern = "invowk.isArgEnvVar.*"
reason = "env var name pattern detection — raw text"

[[exceptions]]
pattern = "invowk.ParseSourceFilter.*"
reason = "source filter display name parsing"

[[exceptions]]
pattern = "invowk.ParseSourceFilter.return.*"
reason = "source filter parsing return"

[[exceptions]]
pattern = "invowk.normalizeSourceName.*"
reason = "source name display normalization"

[[exceptions]]
pattern = "invowk.newServiceError.styledMessage"
reason = "pre-rendered error display text"

# =============================================================================
# Primitive Exceptions — Container / Runtime Boundary
# =============================================================================
# Container engine CLI wrappers and runtime env parsing at exec boundary.

[[exceptions]]
pattern = "container.buildContainerError.engine"
reason = "engine display name for error messages"

[[exceptions]]
pattern = "container.runContainerError.engine"
reason = "engine display name for error messages"

[[exceptions]]
pattern = "container.findPodmanBinary.return.*"
reason = "exec.LookPath return — binary path"

[[exceptions]]
pattern = "BaseCLIEngine.RunCommandWithOutput.return.*"
reason = "raw command stdout capture"

[[exceptions]]
pattern = "BaseCLIEngine.InspectImage.return.*"
reason = "raw docker inspect JSON output"

[[exceptions]]
pattern = "runtime.parseEnvValue.*"
reason = "dotenv parser internal — raw text manipulation"

[[exceptions]]
pattern = "runtime.parseEnvValue.return.*"
reason = "dotenv parser return"

[[exceptions]]
pattern = "runtime.parseDoubleQuotedValue.*"
reason = "dotenv parser internal — raw text manipulation"

[[exceptions]]
pattern = "runtime.parseDoubleQuotedValue.return.*"
reason = "dotenv parser return"

[[exceptions]]
pattern = "runtime.ParseEnvFile.filename"
reason = "dotenv file path — callers pass string from invowkfile"

# Container CLI exec boundary ([]string args passed to docker/podman)
[[exceptions]]
pattern = "BaseCLIEngine.CreateCommand.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "BaseCLIEngine.RunCommand.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "BaseCLIEngine.RunCommandCombined.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "BaseCLIEngine.RunCommandStatus.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "BaseCLIEngine.RunCommandWithOutput.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "SandboxAwareEngine.buildSpawnArgs.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "SandboxAwareEngine.wrapArgs.args"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "BaseCLIEngine.Exec.command"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "BaseCLIEngine.ExecArgs.command"
reason = "container CLI exec boundary"

[[exceptions]]
pattern = "container.isRemotePodman.binaryPath"
reason = "exec boundary — binary path passed to exec"

[[exceptions]]
pattern = "container.sysctlOverrideOpts.binaryPath"
reason = "exec boundary — binary path passed to exec"

# Runtime exec boundary
[[exceptions]]
pattern = "runtime.NativeRuntime.appendPositionalArgs.args"
reason = "exec boundary — shell positional args"

[[exceptions]]
pattern = "runtime.VirtualRuntime.tryUrootBuiltin.args"
reason = "exec boundary — command args"

[[exceptions]]
pattern = "runtime.WithShellArgs.args"
reason = "exec boundary — shell args"

[[exceptions]]
pattern = "runtime.NativeRuntime.shellNotFoundError.attempted"
reason = "display-only error detail"

[[exceptions]]
pattern = "sshserver.Server.runCommand.args"
reason = "exec boundary — command args"

# =============================================================================
# Primitive Exceptions — Provision Internals
# =============================================================================

[[exceptions]]
pattern = "provision.LayerProvisioner.buildProvisionedTag.hash"
reason = "hash string for image tag construction"

[[exceptions]]
pattern = "provision.LayerProvisioner.generateDockerfile.baseImage"
reason = "container image name — display/exec boundary"

# =============================================================================
# Primitive Exceptions — cueutil Internals
# =============================================================================

[[exceptions]]
pattern = "cueutil.formatPath.*"
reason = "CUE path formatting — display text"

[[exceptions]]
pattern = "cueutil.ParseAndDecodeString.schema"
reason = "raw CUE schema text"

[[exceptions]]
pattern = "cueutil.ParseAndDecodeString.schemaPath"
reason = "CUE schema path expression"

[[exceptions]]
pattern = "cueutil.ParseAndDecode.schemaPath"
reason = "CUE schema path expression"

[[exceptions]]
pattern = "cueutil.WithFilename.name"
reason = "CUE parse option — file display name"

[[exceptions]]
pattern = "cueutil.WithMaxFileSize.size"
reason = "CUE parse option — byte size limit"

[[exceptions]]
pattern = "cueutil.CheckFileSize.filename"
reason = "filesystem path for size check"

[[exceptions]]
pattern = "cueutil.CheckFileSize.maxSize"
reason = "byte size limit"

[[exceptions]]
pattern = "cueutil.FormatError.filePath"
reason = "filesystem path for error formatting"

# =============================================================================
# Primitive Exceptions — SSH Server Boundary
# =============================================================================

[[exceptions]]
pattern = "sshserver.Server.GenerateToken.commandID"
reason = "composite string (command identifier)"

[[exceptions]]
pattern = "sshserver.Server.GetConnectionInfo.commandID"
reason = "composite string (command identifier)"

[[exceptions]]
pattern = "sshserver.Server.RevokeTokensForCommand.commandID"
reason = "composite string (command identifier)"

[[exceptions]]
pattern = "sshserver.Server.passwordHandler.password"
reason = "SSH auth boundary — raw credential"

[[exceptions]]
pattern = "sshserver.setWinsize.*"
reason = "terminal size — OS/exec boundary"

# =============================================================================
# Primitive Exceptions — Remaining Miscellaneous
# =============================================================================

[[exceptions]]
pattern = "invowkfile.isLiteralChar.c"
reason = "byte-level character check — parse primitive"

[[exceptions]]
pattern = "invowkfile.isWindowsDriveLetter.c"
reason = "byte-level character check — parse primitive"

[[exceptions]]
pattern = "invowkfile.parseEnvShebang.args"
reason = "exec boundary — shebang args"

[[exceptions]]
pattern = "invowkmod.extractModuleFromInvowkmod.*"
reason = "CUE text extraction — raw content manipulation"

[[exceptions]]
pattern = "invowkmod.ExtractModuleFromCommand.*"
reason = "command name parsing — composite string splitting"

[[exceptions]]
pattern = "invowkfile.ExtractModuleFromCommand.cmd"
reason = "command name parsing — composite string splitting"

[[exceptions]]
pattern = "invowkmod.downloadFile.*"
reason = "HTTP URL + filesystem path — exec/network boundary"

[[exceptions]]
pattern = "invowkmod.downloadFile.return.*"
reason = "filesystem path return — exec boundary"

[[exceptions]]
pattern = "platform.IsWindowsReservedName.name"
reason = "OS-specific name checking — platform boundary"

[[exceptions]]
pattern = "platform.statFile.path"
reason = "filesystem path — OS boundary"

[[exceptions]]
pattern = "config.validateIncludes.fieldName"
reason = "config field name for error messages — display text"

[[exceptions]]
pattern = "execute.validateEnvVarNames.label"
reason = "display label for validation errors"

[[exceptions]]
pattern = "watch.validatePatterns.label"
reason = "display label for validation errors"

[[exceptions]]
pattern = "watch.Watcher.isIgnoredDir.rel"
reason = "relative path — filesystem boundary"

[[exceptions]]
pattern = "watch.Watcher.isIgnored.rel"
reason = "relative path — filesystem boundary"

[[exceptions]]
pattern = "watch.Watcher.matchesPatterns.rel"
reason = "relative path — filesystem boundary"

[[exceptions]]
pattern = "invowkmod.resolveIdentifier.*"
reason = "identifier resolution — composite string parsing"

# =============================================================================
# Filesystem / filepath.Join Boundary (DDD Cost-Benefit Deferred)
# =============================================================================
# These functions accept or return paths at the filesystem boundary where
# filepath.Join(), os.Stat(), t.TempDir() etc. produce raw string values.
# Typing would ADD more casts than it removes — documented via cost-benefit
# analysis. See MEMORY.md "DDD type change cost-benefit" for the principle.
#
# Review cadence: re-evaluate when types.FilesystemPath adoption reaches
# critical mass and stdlib wrappers become cost-effective.

# config internal helpers — callers use filepath.Join results
[[exceptions]]
pattern = "config.fileExists.*"
reason = "filepath.Join boundary — 3 callers pass raw string"
review_after = "2027-03-01"
blocked_by = "types.FilesystemPath adoption in config package"

[[exceptions]]
pattern = "config.loadCUEIntoViper.*"
reason = "filepath.Join boundary — 3 callers pass raw string"
review_after = "2027-03-01"
blocked_by = "types.FilesystemPath adoption in config package"

[[exceptions]]
pattern = "config.cueLoadError.*"
reason = "filepath.Join boundary — 3 callers pass raw string"
review_after = "2027-03-01"
blocked_by = "types.FilesystemPath adoption in config package"

# provision helpers — DiscoverModules returns []string, filepath.Dir returns string
[[exceptions]]
pattern = "provision.CalculateDirHash.*"
reason = "filepath boundary — DiscoverModules returns []string; filepath.Dir"
review_after = "2027-06-01"
blocked_by = "provision package typed path migration"

[[exceptions]]
pattern = "provision.CalculateFileHash.*"
reason = "filepath boundary — callers use string(FilesystemPath)"
review_after = "2027-06-01"
blocked_by = "provision package typed path migration"

[[exceptions]]
pattern = "provision.CopyDir.*"
reason = "filepath.Join recursive boundary — internal calls use filepath.Join"
review_after = "2027-06-01"
blocked_by = "provision package typed path migration"

[[exceptions]]
pattern = "provision.CopyFile.*"
reason = "filepath.Join recursive boundary"
review_after = "2027-06-01"
blocked_by = "provision package typed path migration"

# invowkmod — CUE text manipulation and resolver internals
[[exceptions]]
pattern = "invowkmod.Resolver.*.*"
reason = "resolver internals — filepath.Join and cache path operations"

[[exceptions]]
pattern = "invowkmod.Resolver.*.return.*"
reason = "resolver internal returns"

[[exceptions]]
pattern = "invowkmod.atomicWriteFile.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowkmod.copyDir.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowkmod.copyFile.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowkmod.pruneVendorDir.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowkmod.findModuleInDir.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowkmod.findModuleInDir.return.*"
reason = "filepath boundary return"

[[exceptions]]
pattern = "invowkmod.LoadLockFile.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowkmod.LockFile.Save.*"
reason = "filepath boundary"

# invowkfile — parse/shebang boundary
[[exceptions]]
pattern = "invowkfile.ParseBytes.path"
reason = "filepath.Join boundary — 9+ test sites pass string literals"

[[exceptions]]
pattern = "invowkfile.ParseShebang.content"
reason = "script content — callers receive string from ResolveScript()"

[[exceptions]]
pattern = "invowkfile.ResolveInterpreter.scriptContent"
reason = "script content boundary — 5 callers receive string from ResolveScript()"

[[exceptions]]
pattern = "RuntimeConfig.ResolveInterpreterFromScript.scriptContent"
reason = "script content boundary"

[[exceptions]]
pattern = "invowkfile.ValidateEnvVarName.*"
reason = "callers use strings.TrimSpace(string(...)); map key boundary"

[[exceptions]]
pattern = "invowkfile.FlagNameToEnvVar.return.*"
reason = "result used as map[string]string key — exec/OS boundary"

[[exceptions]]
pattern = "invowkfile.ArgNameToEnvVar.return.*"
reason = "result used as map[string]string key — exec/OS boundary"

[[exceptions]]
pattern = "invowkfile.validateRuntimeConfig.cmdName"
reason = "only called from tests with string literals"

# runtime — dotenv parsing and exec boundaries
[[exceptions]]
pattern = "runtime.LoadEnvFile.*"
reason = "callers mix DotenvFilePath->string and FilesystemPath->string casts"

[[exceptions]]
pattern = "runtime.LoadEnvFileFromCwd.*"
reason = "callers mix WorkDir->string and DotenvFilePath->string casts"

[[exceptions]]
pattern = "runtime.validateWorkDir.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "runtime.lockFilePath.return.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "runtime.acquireRunLockAt.*"
reason = "filepath boundary"

# container — image/provision chain
[[exceptions]]
pattern = "runtime.ContainerRuntime.ensureProvisionedImage.*"
reason = "filepath boundary — invowkDir passed to provisioner"

[[exceptions]]
pattern = "runtime.ContainerRuntime.ensureProvisionedImage.return.*"
reason = "image tag return"

[[exceptions]]
pattern = "runtime.ContainerRuntime.ensureImage.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "runtime.ContainerRuntime.ensureImage.return.*"
reason = "image tag return"

[[exceptions]]
pattern = "runtime.ContainerRuntime.getContainerWorkDir.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "runtime.ContainerRuntime.getContainerWorkDir.return.*"
reason = "container path return"

[[exceptions]]
pattern = "runtime.ContainerRuntime.buildInterpreterCommand.*"
reason = "script content / filepath boundary"

[[exceptions]]
pattern = "runtime.IsTransientExitCode.code"
reason = "int param — callers pass result.ExitCode as int"

[[exceptions]]
pattern = "container.WithName.*"
reason = "container name — display/exec boundary"

# discovery — Cobra boundary
[[exceptions]]
pattern = "discovery.Discovery.GetCommand.name"
reason = "Cobra CLI boundary — callers pass args[0] or ExecuteRequest.Name"

# discovery.Discovery.getAliasForModulePath — typed as (types.FilesystemPath) invowkmod.ModuleAlias
# discovery.getModuleShortName — typed as (types.FilesystemPath) ModuleShortName

# =============================================================================
# cmd/invowk — Cobra / Config / Path Boundary (DDD Cost-Benefit Deferred)
# =============================================================================
# CLI entry point functions that receive values from Cobra, Viper, or
# os.Args. Typing would require casts at every Cobra callback boundary.
#
# Review cadence: re-evaluate if Cobra adds typed flag support or when
# the CLI layer is refactored to use a typed request pattern.

[[exceptions]]
pattern = "invowk.contextWithConfigPath.*"
reason = "Cobra flag binding → FilesystemPath deferred"
review_after = "2027-09-01"
blocked_by = "CLI typed request pattern or Cobra typed flags"

[[exceptions]]
pattern = "invowk.configPathFromContext.return.*"
reason = "Cobra flag binding return"
review_after = "2027-09-01"
blocked_by = "CLI typed request pattern or Cobra typed flags"

[[exceptions]]
pattern = "invowk.loadConfigWithFallback.*"
reason = "Cobra flag binding path"
review_after = "2027-09-01"
blocked_by = "CLI typed request pattern or Cobra typed flags"

[[exceptions]]
pattern = "invowk.commandService.loadConfig.*"
reason = "Cobra flag binding path"
review_after = "2027-09-01"
blocked_by = "CLI typed request pattern or Cobra typed flags"

[[exceptions]]
pattern = "invowk.isExecutable.*"
reason = "filepath boundary — os.Stat callers"

[[exceptions]]
pattern = "invowk.isReadable.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowk.isWritable.*"
reason = "filepath boundary"

[[exceptions]]
pattern = "invowk.runPathValidation.*"
reason = "Cobra args boundary"

[[exceptions]]
pattern = "invowk.runInvowkfilePathValidation.*"
reason = "Cobra args boundary"

[[exceptions]]
pattern = "invowk.runModulePathValidation.*"
reason = "Cobra args boundary"

[[exceptions]]
pattern = "invowk.detectPathType.*"
reason = "filepath boundary — os.Stat callers"

[[exceptions]]
pattern = "invowk.executeInteractive.cmdName"
reason = "Cobra boundary — from args/ExecuteRequest"

[[exceptions]]
pattern = "invowk.validateArguments.cmdName"
reason = "Cobra boundary — display label"

[[exceptions]]
pattern = "invowk.validateFlagValues.cmdName"
reason = "Cobra boundary — display label"

# cmd module commands
[[exceptions]]
pattern = "invowk.runModuleCreate.*"
reason = "Cobra args boundary — module creation params"

[[exceptions]]
pattern = "invowk.runModuleAdd.*"
reason = "Cobra args boundary — module dependency params"

[[exceptions]]
pattern = "invowk.runModuleArchive.*"
reason = "Cobra args boundary — archive output path"

[[exceptions]]
pattern = "invowk.runModuleImport.*"
reason = "Cobra args boundary — import path"

# =============================================================================
# Mop-Up Exceptions (remaining low-value findings)
# =============================================================================

[[exceptions]]
pattern = "watch.Watcher.maybeAddDir.*"
reason = "filepath boundary — fsnotify watcher"
review_after = "2027-06-01"
blocked_by = "fsnotify returns raw string paths"

[[exceptions]]
pattern = "invowkfile.ValidateContainerfilePath.*"
reason = "filepath boundary — os.Stat/filepath.Rel callers"
review_after = "2027-06-01"
blocked_by = "pkg/fspath typed path wrapper adoption"

# =============================================================================
# Constructor Validate() Delegation Exceptions
# =============================================================================
# Constructors where Validate() is intentionally NOT called because:
#   - The constructor IS a non-validating factory (CUE parsing path)
#   - The constructor validates individual parameters inline (redundant)

[[exceptions]]
pattern = "invowkfile.NewModuleMetadataFromInvowkmod.constructor-validate"
reason = "non-validating factory for CUE parsing — validation deferred to caller"

[[exceptions]]
pattern = "invowkfile.NewModuleMetadataFromInvowkmod.constructor-return-error"
reason = "trusted source conversion factory — input Invowkmod is pre-validated by CUE parser"

[[exceptions]]
pattern = "discovery.NewDiagnostic.constructor-validate"
reason = "constructor validates parameters inline via typed Validate() calls"

[[exceptions]]
pattern = "discovery.NewDiagnosticWithPath.constructor-validate"
reason = "constructor validates parameters inline via typed Validate() calls"

[[exceptions]]
pattern = "discovery.NewDiagnosticWithCause.constructor-validate"
reason = "constructor validates parameters inline via typed Validate() calls"

[[exceptions]]
pattern = "execute.NewRuntimeSelection.constructor-validate"
reason = "constructor validates parameters inline — mode.Validate() + nil check match Validate() body"

# =============================================================================
# Cast Validation Exceptions (CFA unvalidated-cast)
# =============================================================================
# Type conversions at established trust boundaries where Validate() is
# unnecessary because the source value is already validated upstream
# (CUE schema, Cobra flags, bubbletea framework, etc.).

# --- TUI framework boundary: bubbletea tea.WindowSizeMsg and huh form values ---
# TerminalDimension/SelectionIndex/DescriptionText from framework-provided ints/strings.
# 3-segment patterns for package-level functions, 4-segment for methods.
[[exceptions]]
pattern = "tui.*.cast-validation"
reason = "TUI framework boundary — bubbletea/huh provides validated values"

[[exceptions]]
pattern = "tui.*.*.cast-validation"
reason = "TUI method boundary — bubbletea/huh provides validated values"

# --- Server state: atomic int32 loads with known enum constants ---

[[exceptions]]
pattern = "serverbase.*.*.cast-validation"
reason = "atomic int32 state loads — method-level state reads via CAS"

# --- Container parsing: 4H tightened (2026-02-28) — 0 findings, blankets removed ---
# Container package has no cast-validation findings (auto-skip contexts handle all casts).

# --- invowkmod: 4H tightened (2026-02-28) — 7 specific patterns replace 2 blankets ---

[[exceptions]]
pattern = "invowkmod.findModuleInDir.cast-validation"
reason = "filesystem boundary — entry.Name() with .invowkmod suffix stripped"

[[exceptions]]
pattern = "invowkmod.parseLockFileCUE.cast-validation"
reason = "parse boundary — CUE-decoded lock file version string"

[[exceptions]]
pattern = "invowkmod.parseModuleKey.cast-validation"
reason = "parse boundary — lock file line to ModuleRefKey conversion"

[[exceptions]]
pattern = "invowkmod.resolveIdentifier.cast-validation"
reason = "parse boundary — user identifier to ModuleRefKey lookup"

[[exceptions]]
pattern = "invowkmod.Resolver.loadTransitiveDeps.cast-validation"
reason = "filesystem boundary — cachePath to FilesystemPath conversion"

[[exceptions]]
pattern = "invowkmod.Resolver.resolveOne.cast-validation"
reason = "filesystem boundary — resolved module path to FilesystemPath"

[[exceptions]]
pattern = "invowkmod.Resolver.List.cast-validation"
reason = "filesystem boundary — cached module path to FilesystemPath"

# --- invowkfile: 4H tightened (2026-02-28) — 0 findings, blankets removed ---
# invowkfile has no cast-validation findings (auto-skip contexts handle all casts).

# --- discovery package: specific filesystem path and identifier cast sites ---
[[exceptions]]
pattern = "discovery.Discovery.New.cast-validation"
reason = "os.Getwd returns valid path or error"

[[exceptions]]
pattern = "discovery.discoverInDir.cast-validation"
reason = "os.Stat confirmed path exists"

[[exceptions]]
pattern = "discovery.Discovery.discoverModulesInDirWithDiagnostics.cast-validation"
reason = "filepath.Abs + os.ReadDir confirmed paths"

[[exceptions]]
pattern = "discovery.Discovery.loadIncludesWithDiagnostics.cast-validation"
reason = "round-trip from config entry.Path"

[[exceptions]]
pattern = "discovery.Discovery.discoverVendoredModulesWithDiagnostics.cast-validation"
reason = "filepath.Join from OS-listed entry"

[[exceptions]]
pattern = "discovery.ValidateCommandTree.cast-validation"
reason = "derived from valid command name parts"

# --- provision package: 4H tightened (2026-02-28) — 0 findings, blankets removed ---
# Provision package has no cast-validation findings (auto-skip contexts handle all casts).

# --- cmd/invowk: 4H tightened (2026-02-28) — 8 specific patterns replace 2 blankets ---

[[exceptions]]
pattern = "invowk.loadConfigWithFallback.cast-validation"
reason = "config boundary — config path to FilesystemPath conversion"

[[exceptions]]
pattern = "invowk.normalizeSourceName.cast-validation"
reason = "parse boundary — raw source string to SourceID conversion"

[[exceptions]]
pattern = "invowk.runInvowkfilePathValidation.cast-validation"
reason = "CLI boundary — Cobra flag to FilesystemPath conversion"

[[exceptions]]
pattern = "invowk.runModulePathValidation.cast-validation"
reason = "CLI boundary — Cobra flag to FilesystemPath conversion"

[[exceptions]]
pattern = "invowk.runModuleAdd.cast-validation"
reason = "CLI boundary — Cobra args to DDD type conversions"

[[exceptions]]
pattern = "invowk.runModuleArchive.cast-validation"
reason = "CLI boundary — Cobra args to DDD type conversions"

[[exceptions]]
pattern = "invowk.runModuleCreate.cast-validation"
reason = "CLI boundary — Cobra args to DDD type conversions"

[[exceptions]]
pattern = "invowk.runModuleImport.cast-validation"
reason = "CLI boundary — Cobra args to DDD type conversions"

# =============================================================================
# 4F: TUI/Container/Env Map — Baseline-to-Exception Migration
# =============================================================================
# Framework-boundary findings migrated from baseline to exceptions. These are
# genuine exec/OS/rendering boundaries with no domain semantics beyond the
# framework they interact with.

# --- TUI Internal Model State (unexported bubbletea model structs) ---
# Unexported TUI model structs hold transient UI state (cursor position,
# frame list, title text, selection result) with no domain semantics beyond
# the bubbletea/huh rendering pipeline.

[[exceptions]]
pattern = "tui.*Model.*"
reason = "unexported bubbletea model state — rendering cursor/selection/viewport, no domain semantics"

[[exceptions]]
pattern = "tui.*Item.*"
reason = "unexported bubbletea list.Item internals — display text only"

[[exceptions]]
pattern = "tui.outputMsg.*"
reason = "unexported bubbletea message — display text only"

# --- TUI Public Options/Result Struct Fields ---

[[exceptions]]
pattern = "tui.FileOptions.AllowedExtensions"
reason = "display filter list — file extension strings"

[[exceptions]]
pattern = "tui.FileOptions.CurrentDirectory"
reason = "filesystem path seed for file picker — OS boundary"

[[exceptions]]
pattern = "tui.PagerOptions.Content"
reason = "raw display text passed to pager renderer"

[[exceptions]]
pattern = "tui.TableSelectionResult.SelectedRow"
reason = "display row data — parallel to [][]string table rows"

# --- TUI Builder.Run Return Values ---
# Builder.Run() methods return user-entered display text or selection results
# that are immediately consumed by the TUI rendering pipeline.

[[exceptions]]
pattern = "tui.*Builder.*.return.*"
reason = "Builder.Run() returns user-entered display text or selection results"

# --- TUI ANSI Rendering Function Returns ---
# Top-level ANSI functions return processed display strings. Their params
# are already excepted; these cover the return values.

[[exceptions]]
pattern = "tui.compositeLineANSI.return.*"
reason = "ANSI rendering return — processed display string"

[[exceptions]]
pattern = "tui.getANSISuffix.return.*"
reason = "ANSI rendering return — ANSI suffix string"

[[exceptions]]
pattern = "tui.hexToANSIBackground.return.*"
reason = "ANSI rendering return — background escape sequence"

[[exceptions]]
pattern = "tui.sanitizeModalBackground.return.*"
reason = "ANSI rendering return — sanitized background string"

[[exceptions]]
pattern = "tui.stripOSCSequences.return.*"
reason = "ANSI rendering return — stripped display string"

[[exceptions]]
pattern = "tui.padLineToWidth.return.*"
reason = "ANSI rendering return — padded display string"

[[exceptions]]
pattern = "tui.RenderOverlay.return.*"
reason = "ANSI rendering return — rendered overlay string"

# --- Container Engine Exec Boundary Returns ---
# All container engine methods return []string args or string identifiers
# for direct consumption by exec.CommandContext or display.

[[exceptions]]
pattern = "container.BaseCLIEngine.ExecArgs.return.*"
reason = "exec boundary — []string args for exec.CommandContext"

[[exceptions]]
pattern = "container.BaseCLIEngine.BuildArgs.return.*"
reason = "exec boundary — []string args for 'docker build'"

[[exceptions]]
pattern = "container.BaseCLIEngine.BuildRunArgs.return.*"
reason = "exec boundary — []string args for 'docker run' variant"

[[exceptions]]
pattern = "container.BaseCLIEngine.RunArgs.return.*"
reason = "exec boundary — []string args for 'docker run'"

[[exceptions]]
pattern = "container.BaseCLIEngine.RemoveArgs.return.*"
reason = "exec boundary — []string args for 'docker rm'"

[[exceptions]]
pattern = "container.BaseCLIEngine.RemoveImageArgs.return.*"
reason = "exec boundary — []string args for 'docker rmi'"

[[exceptions]]
pattern = "container.BaseCLIEngine.BinaryPath.return.*"
reason = "exec boundary — binary path for engine consumers"

[[exceptions]]
pattern = "container.BaseCLIEngine.Name.return.*"
reason = "engine display name — display label"

[[exceptions]]
pattern = "container.SandboxAwareEngine.Name.return.*"
reason = "engine display name — decorator pass-through"

[[exceptions]]
pattern = "container.SandboxAwareEngine.BinaryPath.return.*"
reason = "exec boundary — binary path pass-through"

[[exceptions]]
pattern = "container.SandboxAwareEngine.BuildRunArgs.return.*"
reason = "exec boundary — []string args builder"

[[exceptions]]
pattern = "container.SandboxAwareEngine.buildSpawnArgs.return.*"
reason = "exec boundary — []string spawn args builder"

[[exceptions]]
pattern = "container.SandboxAwareEngine.wrapArgs.return.*"
reason = "exec boundary — []string args wrapper"

[[exceptions]]
pattern = "container.SandboxAwareEngine.getSpawnInfo.return.*"
reason = "exec boundary — spawn command and args named returns"

[[exceptions]]
pattern = "container.createSysctlOverrideTempFile.return.*"
reason = "exec boundary — temp file path returned to docker run"

[[exceptions]]
pattern = "container.addSELinuxLabelWithCheck.return.*"
reason = "exec boundary — docker run flag string"

[[exceptions]]
pattern = "container.ResolveDockerfilePath.return.*"
reason = "exec boundary — resolved Dockerfile path"

[[exceptions]]
pattern = "container.ParsePortMapping.portStr"
reason = "exec boundary — raw port string for parsing"

[[exceptions]]
pattern = "container.ParseVolumeMount.volume"
reason = "exec boundary — raw volume spec string for parsing"

[[exceptions]]
pattern = "container.WithCmdEnvOverride.key"
reason = "exec/OS boundary — env var key override"

[[exceptions]]
pattern = "container.WithCmdEnvOverride.value"
reason = "exec/OS boundary — env var value override"

[[exceptions]]
pattern = "container.RetryWithBackoff.maxAttempts"
reason = "retry count — structural config integer"

# --- Provision Layer Exec Boundary ---

[[exceptions]]
pattern = "provision.LayerProvisioner.buildEnvVars.return.*"
reason = "exec boundary — env map for container runtime injection"

[[exceptions]]
pattern = "provision.Result.EnvVars"
reason = "exec boundary — provisioned env map passed to container runtime"

[[exceptions]]
pattern = "provision.LayerProvisioner.buildProvisionedTag.return.*"
reason = "exec boundary — image tag string for docker build/run"

[[exceptions]]
pattern = "provision.LayerProvisioner.calculateCacheKey.return.*"
reason = "content-hash string — hex hash for cache invalidation"

[[exceptions]]
pattern = "provision.LayerProvisioner.getImageIdentifier.return.*"
reason = "exec boundary — image identifier string for docker"

[[exceptions]]
pattern = "provision.LayerProvisioner.GetProvisionedImageTag.return.*"
reason = "exec boundary — provisioned image tag returned to runtime"

[[exceptions]]
pattern = "provision.LayerProvisioner.prepareBuildContext.return.*"
reason = "exec boundary — build context dir path for docker build"

[[exceptions]]
pattern = "provision.DiscoverModules.return.*"
reason = "exec boundary — list of module paths for provisioning"

[[exceptions]]
pattern = "provision.WithTagSuffix.suffix"
reason = "functional option param — tag suffix string"

[[exceptions]]
pattern = "provision.CalculateFileHash.return.*"
reason = "content-hash string — hex hash for cache key"

[[exceptions]]
pattern = "provision.CalculateDirHash.return.*"
reason = "content-hash string — hex hash for cache key"

# --- Runtime Env Map / Exec Boundary ---
# OS environment maps (map[string]string) at the exec/shell boundary where
# typing would break os.Environ() and exec.Cmd compatibility.

[[exceptions]]
pattern = "runtime.buildHostEnv.return.*"
reason = "exec/OS boundary — captured host environment map[string]string"

[[exceptions]]
pattern = "runtime.DefaultEnvBuilder.Build.return.*"
reason = "exec/OS boundary — env map for exec.CommandContext"

[[exceptions]]
pattern = "runtime.MockEnvBuilder.Build.return.*"
reason = "test-only mock — exec/OS boundary return"

[[exceptions]]
pattern = "runtime.MockEnvBuilder.Env"
reason = "test-only mock state — exec/OS boundary"

[[exceptions]]
pattern = "runtime.ParseEnvFile.env"
reason = "exec/OS boundary — parsed dotenv key-value pairs"

[[exceptions]]
pattern = "runtime.EnvToSlice.env"
reason = "exec/OS boundary — env map for slice conversion"

[[exceptions]]
pattern = "runtime.EnvToSlice.return.*"
reason = "exec/OS boundary — env KEY=VALUE string slice"

[[exceptions]]
pattern = "runtime.FilterInvowkEnvVars.environ"
reason = "exec/OS boundary — raw environ strings"

[[exceptions]]
pattern = "runtime.FilterInvowkEnvVars.return.*"
reason = "exec/OS boundary — filtered environ strings"

[[exceptions]]
pattern = "runtime.ContainerRuntime.setupSSHConnection.env"
reason = "exec/OS boundary — env map for SSH container config"

[[exceptions]]
pattern = "runtime.EnvContext.WithVar.key"
reason = "exec/OS boundary — env var key passed to os.Setenv"

[[exceptions]]
pattern = "runtime.EnvContext.WithVar.value"
reason = "exec/OS boundary — env var value passed to os.Setenv"

[[exceptions]]
pattern = "runtime.shouldFilterEnvVar.name"
reason = "exec/OS boundary — env var name for filter check"

# --- Runtime Shell / Exec Boundary ---
# Shell args, interpreter paths, script content at the shell execution boundary.

[[exceptions]]
pattern = "runtime.NativeRuntime.shellArgs"
reason = "exec boundary — cached shell args []string"

[[exceptions]]
pattern = "runtime.NativeRuntime.ShellArgs.return.*"
reason = "exec boundary — shell args for command construction"

[[exceptions]]
pattern = "runtime.NativeRuntime.getShell.return.*"
reason = "exec boundary — resolved shell binary path"

[[exceptions]]
pattern = "runtime.NativeRuntime.getShellArgs.return.*"
reason = "exec boundary — shell invocation args"

[[exceptions]]
pattern = "runtime.NativeRuntime.getShellArgs.shell"
reason = "exec boundary — shell binary path input"

[[exceptions]]
pattern = "runtime.NativeRuntime.appendPositionalArgs.shell"
reason = "exec boundary — shell name for arg style detection"

[[exceptions]]
pattern = "runtime.NativeRuntime.appendPositionalArgs.positionalArgs"
reason = "exec boundary — raw positional args []string"

[[exceptions]]
pattern = "runtime.NativeRuntime.appendPositionalArgs.return.*"
reason = "exec boundary — shell args with appended positional args"

[[exceptions]]
pattern = "runtime.NativeRuntime.createTempScript.interpreter"
reason = "exec boundary — interpreter binary name"

[[exceptions]]
pattern = "runtime.NativeRuntime.createTempScript.content"
reason = "exec boundary — script content for temp file"

[[exceptions]]
pattern = "runtime.NativeRuntime.createTempScript.return.*"
reason = "exec boundary — temp script file path"

[[exceptions]]
pattern = "runtime.NativeRuntime.Name.return.*"
reason = "display text — runtime display name"

[[exceptions]]
pattern = "runtime.NativeRuntime.executeInterpreterCommon.script"
reason = "exec boundary — script content for interpreter"

[[exceptions]]
pattern = "runtime.NativeRuntime.executeShellCommon.script"
reason = "exec boundary — script content for shell"

[[exceptions]]
pattern = "runtime.NativeRuntime.prepareInterpreterCommand.script"
reason = "exec boundary — script content for command construction"

[[exceptions]]
pattern = "runtime.NativeRuntime.prepareShellCommand.script"
reason = "exec boundary — script content for shell command"

[[exceptions]]
pattern = "runtime.ContainerRuntime.Name.return.*"
reason = "display text — runtime display name"

[[exceptions]]
pattern = "runtime.ContainerRuntime.GetEngineName.return.*"
reason = "display text — container engine display name"

[[exceptions]]
pattern = "runtime.ContainerRuntime.GetHostAddressForContainer.return.*"
reason = "exec boundary — host address string for container networking"

[[exceptions]]
pattern = "runtime.ContainerRuntime.buildInterpreterCommand.return.*"
reason = "exec boundary — interpreter command []string and temp file path"

[[exceptions]]
pattern = "runtime.ContainerRuntime.generateImageTag.invowkfilePath"
reason = "exec boundary — invowkfile path for image tag computation"

[[exceptions]]
pattern = "runtime.VirtualRuntime.Name.return.*"
reason = "display text — runtime display name"

[[exceptions]]
pattern = "runtime.lockFilePathWith.return.*"
reason = "exec boundary — lock file path string"

[[exceptions]]
pattern = "runtime.isAlpineContainerImage.image"
reason = "exec boundary — container image name for detection"

[[exceptions]]
pattern = "runtime.isWindowsContainerImage.image"
reason = "exec boundary — container image name for detection"

# --- cmd/invowk: CLI / Cobra Boundary ---
# Cobra args, config paths, env vars, and rendering at the CLI boundary.

[[exceptions]]
pattern = "invowk.appDiscoveryService.GetCommand.name"
reason = "CLI boundary — command name from Cobra args"

[[exceptions]]
pattern = "invowk.buildLeafCommand.cmdPart"
reason = "CLI boundary — command path segment from Cobra"

[[exceptions]]
pattern = "invowk.buildCommandUsageString.cmdPart"
reason = "CLI boundary — command path segment for usage string"

[[exceptions]]
pattern = "invowk.validateHostDependencies.userEnv"
reason = "exec/OS boundary — captured user environment for validation"

[[exceptions]]
pattern = "invowk.validateDependencies.userEnv"
reason = "exec/OS boundary — user environment passthrough"

[[exceptions]]
pattern = "invowk.commandService.validateAndRenderDeps.userEnv"
reason = "exec/OS boundary — user environment passthrough"

[[exceptions]]
pattern = "invowk.checkEnvVarDependencies.userEnv"
reason = "exec/OS boundary — user environment check"

[[exceptions]]
pattern = "invowk.parseEnvVarFlags.return.*"
reason = "CLI boundary — Cobra --env flag parse result"

[[exceptions]]
pattern = "invowk.parseEnvVarFlags.envVarFlags"
reason = "CLI boundary — raw Cobra --env flag values"

[[exceptions]]
pattern = "invowk.validateFlagValues.flagValues"
reason = "CLI boundary — user-provided flag value strings"

[[exceptions]]
pattern = "invowk.validateArguments.providedArgs"
reason = "CLI boundary — positional args from Cobra"

[[exceptions]]
pattern = "invowk.RenderHostNotSupportedError.currentOS"
reason = "display text — OS name for error rendering"

[[exceptions]]
pattern = "invowk.RenderHostNotSupportedError.cmdName"
reason = "display text — command name for error rendering"

[[exceptions]]
pattern = "invowk.RenderHostNotSupportedError.supportedHosts"
reason = "display text — host list for error rendering"

[[exceptions]]
pattern = "invowk.RenderRuntimeNotAllowedError.cmdName"
reason = "display text — command name for error rendering"

[[exceptions]]
pattern = "invowk.RenderRuntimeNotAllowedError.selectedRuntime"
reason = "display text — runtime name for error rendering"

[[exceptions]]
pattern = "invowk.RenderRuntimeNotAllowedError.allowedRuntimes"
reason = "display text — runtime list for error rendering"

[[exceptions]]
pattern = "invowk.runInit.template"
reason = "CLI boundary — user-specified template name"

[[exceptions]]
pattern = "invowk.generateInvowkfile.template"
reason = "CLI boundary — template name for file generation"

[[exceptions]]
pattern = "invowk.getVersionString.version"
reason = "build metadata — injected version string"

[[exceptions]]
pattern = "invowk.getVersionString.commit"
reason = "build metadata — injected commit hash"

[[exceptions]]
pattern = "invowk.getVersionString.buildDate"
reason = "build metadata — injected build date"

[[exceptions]]
pattern = "invowk.formatFileSize.size"
reason = "display text — file size for human-readable output"

[[exceptions]]
pattern = "invowk.toEnvVarNames.names"
reason = "CLI boundary — raw env var name strings from user input"

[[exceptions]]
pattern = "invowk.toDotenvFilePaths.paths"
reason = "CLI boundary — raw dotenv file path strings from user input"

[[exceptions]]
pattern = "invowk.capabilityCheckScript.return.*"
reason = "exec boundary — generated script content"

[[exceptions]]
pattern = "invowk.detectPathType.return.*"
reason = "exec boundary — resolved filesystem path"

[[exceptions]]
pattern = "invowk.ServiceError.StyledMessage"
reason = "display text — pre-rendered error message for TUI"

# --- Platform Exec Boundary ---

[[exceptions]]
pattern = "platform.GetSpawnCommand.return.*"
reason = "exec/OS boundary — platform-specific spawn command"

[[exceptions]]
pattern = "platform.SpawnCommandFor.return.*"
reason = "exec/OS boundary — platform-specific spawn command"

[[exceptions]]
pattern = "platform.GetSpawnArgs.return.*"
reason = "exec/OS boundary — platform-specific spawn args"

[[exceptions]]
pattern = "platform.SpawnArgsFor.return.*"
reason = "exec/OS boundary — platform-specific spawn args"

# --- Small Packages: sshserver, config, cueutil, fspath, discovery, serverbase ---

[[exceptions]]
pattern = "sshserver.Server.Address.return.*"
reason = "wire boundary — listening address string"

[[exceptions]]
pattern = "sshserver.copyBuffer.return.*"
reason = "wire boundary — bytes copied int64"

[[exceptions]]
pattern = "config.loadWithOptions.return.*"
reason = "config path return — resolved config file path"

[[exceptions]]
pattern = "cueutil.formatPath.return.*"
reason = "CUE internals — formatted CUE path string"

[[exceptions]]
pattern = "cueutil.parseOptions.filename"
reason = "CUE internals — filename for parse context"

[[exceptions]]
pattern = "cueutil.parseOptions.maxFileSize"
reason = "CUE internals — size limit config int64"

[[exceptions]]
pattern = "fspath.JoinStr.elem"
reason = "typed boundary wrapper — raw string elems for filepath.Join centralization"

[[exceptions]]
pattern = "discovery.Diagnostic.Message.return.*"
reason = "display text — diagnostic message for user output"

[[exceptions]]
pattern = "serverbase.WithErrorChannel.size"
reason = "buffer size integer — error channel capacity"

# --- invowkmod: Version/CUE Parsing Boundary ---

[[exceptions]]
pattern = "invowkmod.ParseVersion.s"
reason = "parse boundary — raw version string input"

[[exceptions]]
pattern = "invowkmod.isValidVersionString.s"
reason = "parse boundary — raw version string for validation"

[[exceptions]]
pattern = "invowkmod.isGitURL.s"
reason = "parse boundary — raw URL string for git detection"

[[exceptions]]
pattern = "invowkmod.isSupportedGitURLPrefix.url"
reason = "parse boundary — raw URL string for prefix check"

[[exceptions]]
pattern = "invowkmod.SemverResolver.ParseConstraint.s"
reason = "parse boundary — raw constraint string input"

[[exceptions]]
pattern = "invowkmod.IsValidConstraint.s"
reason = "parse boundary — raw constraint string for validation"

[[exceptions]]
pattern = "invowkmod.FilterVersions.constraintStr"
reason = "parse boundary — raw constraint string for filtering"

[[exceptions]]
pattern = "invowkmod.computeNamespace.version"
reason = "parse boundary — raw version string for namespace computation"

[[exceptions]]
pattern = "invowkmod.ParseModuleName.folderName"
reason = "filesystem boundary — directory name for module parsing"

[[exceptions]]
pattern = "invowkmod.extractFile.destPath"
reason = "filesystem boundary — extraction destination path"

[[exceptions]]
pattern = "invowkmod.buildAmbiguousError.identifier"
reason = "display text — identifier for error message"

[[exceptions]]
pattern = "invowkmod.extractModuleFromInvowkmod.return.*"
reason = "parse boundary — extracted module ID from CUE source"

[[exceptions]]
pattern = "invowkmod.ExtractModuleFromCommand.return.*"
reason = "parse boundary — extracted module ID from command name"

[[exceptions]]
pattern = "invowkmod.Create.return.*"
reason = "filesystem boundary — created module directory path"

[[exceptions]]
pattern = "invowkmod.Unpack.return.*"
reason = "filesystem boundary — extracted module path"

[[exceptions]]
pattern = "invowkmod.pruneVendorDir.return.*"
reason = "filesystem boundary — pruned directory paths"

[[exceptions]]
pattern = "invowkmod.ValidationResult.AddIssue.message"
reason = "display text — validation issue message"

[[exceptions]]
pattern = "invowkmod.ValidationResult.AddIssue.path"
reason = "display text — validation issue path context"

[[exceptions]]
pattern = "invowkmod.Module.checkSymlinkSafety.path"
reason = "filesystem boundary — path for symlink safety check"

[[exceptions]]
pattern = "invowkmod.CommandScope.CanCall.targetCmd"
reason = "display text — target command name for scope check"

[[exceptions]]
pattern = "invowkmod.CommandScope.CanCall.return.*"
reason = "display text — rejection reason string"

# --- invowkfile: Validation / Parse Internals ---

[[exceptions]]
pattern = "invowkfile.matchesValidation.value"
reason = "parse boundary — raw value for validation matching"

[[exceptions]]
pattern = "invowkfile.matchesValidation.pattern"
reason = "parse boundary — regex pattern for validation"

[[exceptions]]
pattern = "invowkfile.validateValueType.value"
reason = "parse boundary — raw value for type validation"

[[exceptions]]
pattern = "invowkfile.validateValueWithRegex.value"
reason = "parse boundary — raw value for regex validation"

[[exceptions]]
pattern = "invowkfile.validateValueWithRegex.pattern"
reason = "parse boundary — regex pattern for validation"

[[exceptions]]
pattern = "invowkfile.validateValueWithRegex.name"
reason = "display text — field name for error messages"

[[exceptions]]
pattern = "invowkfile.ValidateStringLength.value"
reason = "parse boundary — raw value for length check"

[[exceptions]]
pattern = "invowkfile.ValidateStringLength.fieldName"
reason = "display text — field name for error messages"

[[exceptions]]
pattern = "invowkfile.ValidateStringLength.maxLen"
reason = "config integer — max length threshold"

[[exceptions]]
pattern = "invowkfile.ValidateEnvFilePath.filePath"
reason = "parse boundary — raw env file path for validation"

[[exceptions]]
pattern = "invowkfile.ValidateRegexPattern.pattern"
reason = "parse boundary — raw regex pattern for validation"

[[exceptions]]
pattern = "invowkfile.ValidatePortMapping.port"
reason = "parse boundary — raw port string for validation"

[[exceptions]]
pattern = "invowkfile.ValidateVolumeMount.volume"
reason = "parse boundary — raw volume spec for validation"

[[exceptions]]
pattern = "invowkfile.ValidateFilename.name"
reason = "parse boundary — raw filename for validation"

[[exceptions]]
pattern = "invowkfile.validatePortNumber.s"
reason = "parse boundary — raw port number string"

[[exceptions]]
pattern = "invowkfile.isValidIPAddress.s"
reason = "parse boundary — raw IP address string"

[[exceptions]]
pattern = "invowkfile.isAbsolutePath.path"
reason = "parse boundary — raw path for absolute check"

[[exceptions]]
pattern = "invowkfile.checkNestingDepth.pattern"
reason = "parse boundary — regex pattern for nesting check"

[[exceptions]]
pattern = "invowkfile.checkDangerousPatterns.pattern"
reason = "parse boundary — regex pattern for danger check"

[[exceptions]]
pattern = "invowkfile.checkQuantifierCount.pattern"
reason = "parse boundary — regex pattern for quantifier check"

[[exceptions]]
pattern = "invowkfile.hasOverlappingAlternation.pattern"
reason = "parse boundary — regex pattern for overlap check"

[[exceptions]]
pattern = "invowkfile.matchesSensitivePattern.path"
reason = "parse boundary — raw path for sensitive pattern check"

[[exceptions]]
pattern = "invowkfile.matchesSensitivePattern.patternParts"
reason = "parse boundary — pattern parts for matching"

[[exceptions]]
pattern = "invowkfile.regexpMatch.s"
reason = "parse boundary — raw string for regex match"

[[exceptions]]
pattern = "invowkfile.regexpMatch.pattern"
reason = "parse boundary — regex pattern for match"

[[exceptions]]
pattern = "invowkfile.parseDuration.fieldName"
reason = "display text — field name for error messages"

[[exceptions]]
pattern = "invowkfile.ParseRuntimeMode.value"
reason = "parse boundary — raw value for enum parsing"

[[exceptions]]
pattern = "invowkfile.ParseEnvInheritMode.value"
reason = "parse boundary — raw value for enum parsing"

[[exceptions]]
pattern = "invowkfile.IsShellInterpreter.interpreter"
reason = "parse boundary — interpreter name for shell detection"

[[exceptions]]
pattern = "invowkfile.GetExtensionForInterpreter.interpreter"
reason = "parse boundary — interpreter name for extension lookup"

[[exceptions]]
pattern = "invowkfile.GetExtensionForInterpreter.return.*"
reason = "parse boundary — file extension string"

[[exceptions]]
pattern = "invowkfile.Flag.ValidateFlagValue.value"
reason = "parse boundary — raw user-provided flag value"

[[exceptions]]
pattern = "invowkfile.Argument.ValidateArgumentValue.value"
reason = "parse boundary — raw user-provided argument value"

[[exceptions]]
pattern = "invowkfile.NewValidationError.field"
reason = "display text — field name for validation error"

[[exceptions]]
pattern = "invowkfile.ValidationError.Message"
reason = "display text — validation error message"

[[exceptions]]
pattern = "invowkfile.engineCandidate.name"
reason = "exec boundary — container engine binary name"

[[exceptions]]
pattern = "invowkfile.engineCandidate.args"
reason = "exec boundary — container engine detection args"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateFlag.seenNames"
reason = "set-tracking idiom — deduplication map key"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateFlag.seenShorts"
reason = "set-tracking idiom — deduplication map key"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateFlag.idx"
reason = "collection index — flag position in list"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateArg.seenNames"
reason = "set-tracking idiom — deduplication map key"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateArg.idx"
reason = "collection index — argument position in list"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateImplementation.implIdx"
reason = "collection index — implementation position in list"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateRuntimeConfig.implIdx"
reason = "collection index — implementation position in list"

[[exceptions]]
pattern = "invowkfile.StructureValidator.validateRuntimeConfig.rtIdx"
reason = "collection index — runtime config position in list"

[[exceptions]]
pattern = "invowkfile.validateRuntimeConfig.implIndex"
reason = "collection index — implementation position in list"

[[exceptions]]
pattern = "invowkfile.RuntimeConfig.GetEffectiveInterpreter.return.*"
reason = "exec boundary — resolved interpreter binary path"

[[exceptions]]
pattern = "invowkfile.Implementation.ResolveScript.return.*"
reason = "exec boundary — resolved script content"

[[exceptions]]
pattern = "invowkfile.Implementation.ResolveScriptWithFS.return.*"
reason = "exec boundary — resolved script content"

[[exceptions]]
pattern = "invowkfile.Implementation.ResolveScriptWithModule.return.*"
reason = "exec boundary — resolved script content"

[[exceptions]]
pattern = "invowkfile.Implementation.ResolveScriptWithFSAndModule.return.*"
reason = "exec boundary — resolved script content"

[[exceptions]]
pattern = "invowkfile.Invowkfile.ListCommands.return.*"
reason = "display/CLI boundary — command name list for Cobra registration"

[[exceptions]]
pattern = "invowkfile.CompositeValidator.Count.return.*"
reason = "aggregate count — number of validation errors"

[[exceptions]]
pattern = "invowkfile.ExtractModuleFromCommand.return.*"
reason = "parse boundary — extracted module ID from command string"

[[exceptions]]
pattern = "invowkfile.EnvConfig.GetVars.return.*"
reason = "exec/OS boundary — env map for runtime consumption"

[[exceptions]]
pattern = "invowkfile.NewCommandScope.moduleID"
reason = "parse boundary — module ID string from discovery"

[[exceptions]]
pattern = "invowkfile.NewCommandScope.globalModuleIDs"
reason = "parse boundary — module ID list from discovery"

# --- 1G: ModuleShortName Unvalidated-Cast ---
# Filesystem boundary — OS-listed directory names already validated by discovery.

[[exceptions]]
pattern = "invowkmod.findModuleInDir.cast-validation"
reason = "filesystem boundary — entry.Name() with .invowkmod suffix stripped; validated by discovery"

[[exceptions]]
pattern = "discovery.getModuleShortName.cast-validation"
reason = "filesystem boundary — module short name derived from validated module path"

# --- Remaining Exec Boundary Primitives ---

[[exceptions]]
pattern = "runtime.ExecutionContext.EffectiveWorkDir.return.*"
reason = "exec boundary — resolved working directory path for runtime"

[[exceptions]]
pattern = "container.SandboxAwareEngine.buildSpawnArgs.binary"
reason = "exec boundary — binary path for container spawn"

# =============================================================================
# Nonzero Error Type Fields
# =============================================================================
# Error structs carry the offending value for diagnostic messages.
# These must be value types (not pointers) even though the underlying
# type has //goplint:nonzero, because the error always contains a
# concrete invalid value to report.

[[exceptions]]
pattern = "invowkfile.InvalidCapabilityNameError.Value.nonzero"
reason = "error struct carries offending value for diagnostic output"

[[exceptions]]
pattern = "invowkfile.CapabilityError.Capability.nonzero"
reason = "error struct carries offending capability for diagnostic output"

# =============================================================================
# Orphaned Validator Audit — Constant-Only Types
# =============================================================================
# All 8 constant-only types now have //goplint:constant-only directives on
# their type declarations, making them self-documenting and exempt from
# --check-constructor-validates without needing TOML entries.
#
# Annotated types: platform.SandboxType, runtime.InitDiagnosticCode,
# issue.Id, issue.MarkdownMsg, issue.HttpLink, invowk.ArgErrType,
# invowkfile.ValidationSeverity, invowkfile.ValidatorName.
# =============================================================================
