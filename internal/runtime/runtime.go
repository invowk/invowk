// SPDX-License-Identifier: MPL-2.0

package runtime

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync/atomic"
	"time"

	"github.com/invowk/invowk/pkg/invowkfile"
	"github.com/invowk/invowk/pkg/platform"
)

// Runtime type constants for different execution environments.
const (
	RuntimeTypeNative    RuntimeType = "native"
	RuntimeTypeVirtual   RuntimeType = "virtual"
	RuntimeTypeContainer RuntimeType = "container"
)

var (
	// ErrRuntimeNotAvailable is returned when the requested runtime is not available on the current system.
	// Callers can check for this error using errors.Is(err, ErrRuntimeNotAvailable).
	ErrRuntimeNotAvailable = errors.New("runtime not available")

	// ErrInvalidRuntimeType is returned when a RuntimeType value is not one of the defined runtime types.
	ErrInvalidRuntimeType = errors.New("invalid runtime type")

	// ErrInvalidExecutionID is the sentinel error wrapped by InvalidExecutionIDError.
	ErrInvalidExecutionID = errors.New("invalid execution ID")

	// executionIDPattern validates the nanoseconds-counter format used by NewExecutionID.
	executionIDPattern = regexp.MustCompile(`^\d+-\d+$`)
)

type (
	// ExecutionID is a unique identifier for a command execution.
	// Format: "<nanoseconds>-<counter>" generated by Registry.NewExecutionID().
	ExecutionID string

	// InvalidExecutionIDError is returned when an ExecutionID value does not
	// match the expected nanoseconds-counter format.
	InvalidExecutionIDError struct {
		Value ExecutionID
	}

	// IOContext holds I/O streams for command execution.
	// This groups standard input, output, and error streams together.
	IOContext struct {
		// Stdout is where to write standard output
		Stdout io.Writer
		// Stderr is where to write standard error
		Stderr io.Writer
		// Stdin is where to read standard input
		Stdin io.Reader
	}

	// EnvContext holds environment configuration for command execution.
	// This groups all environment variable related fields together.
	EnvContext struct {
		// ExtraEnv contains additional environment variables (INVOWK_FLAG_*, INVOWK_ARG_*, etc.)
		ExtraEnv map[string]string
		// RuntimeEnvVars contains env vars specified via --ivk-env-var flag.
		// These are set last and override all other environment variables (highest priority).
		RuntimeEnvVars map[string]string
		// RuntimeEnvFiles contains dotenv file paths specified via --ivk-env-file flag.
		// These are loaded after all other env sources but before RuntimeEnvVars.
		// Relative paths are resolved against Cwd (or os.Getwd() when Cwd is empty).
		RuntimeEnvFiles []invowkfile.DotenvFilePath
		// InheritModeOverride overrides the runtime config env inherit mode when set.
		InheritModeOverride invowkfile.EnvInheritMode
		// InheritAllowOverride overrides the runtime config allowlist when set.
		InheritAllowOverride []invowkfile.EnvVarName
		// InheritDenyOverride overrides the runtime config denylist when set.
		InheritDenyOverride []invowkfile.EnvVarName
		// Cwd overrides the working directory for --ivk-env-file path resolution.
		// When empty, os.Getwd() is used.
		Cwd invowkfile.WorkDir
	}

	// TUIContext holds TUI server connection details for interactive mode.
	// This groups TUI-related fields together.
	TUIContext struct {
		// ServerURL is the URL of the TUI server for interactive mode.
		// When set, runtimes should include this in the command's environment
		// as INVOWK_TUI_ADDR. For container runtimes, this should already be
		// translated to a container-accessible address (e.g., host.docker.internal).
		ServerURL TUIServerURL
		// ServerToken is the authentication token for the TUI server.
		// When set, runtimes should include this in the command's environment
		// as INVOWK_TUI_TOKEN.
		ServerToken TUIServerToken
	}

	// ExecutionContext contains all information needed to execute a command.
	// It uses composition of focused sub-types (IO, Env, TUI) for better
	// organization and testability.
	//
	// SelectedRuntime and SelectedImpl are resolved together: SelectedImpl is the
	// implementation matching SelectedRuntime + current platform. Both are populated
	// by NewExecutionContext using the command's defaults and can be overridden by
	// CLI flag processing (e.g., --ivk-runtime flag).
	ExecutionContext struct {
		// Command is the command to execute
		Command *invowkfile.Command
		// Invowkfile is the parent invowkfile
		Invowkfile *invowkfile.Invowkfile
		// Context is the Go context for cancellation
		Context context.Context
		// SelectedRuntime is the runtime to use for execution (may differ from default)
		SelectedRuntime invowkfile.RuntimeMode
		// SelectedImpl is the implementation to execute (based on platform and runtime)
		SelectedImpl *invowkfile.Implementation
		// PositionalArgs contains command-line arguments to pass as shell positional parameters ($1, $2, etc.)
		PositionalArgs []string
		// WorkDir overrides the working directory
		WorkDir invowkfile.WorkDir
		// Verbose enables verbose output
		Verbose bool
		// ForceRebuild forces container image rebuilds, bypassing cache (container runtime only)
		ForceRebuild bool
		// ExecutionID is a unique identifier for this command execution.
		ExecutionID ExecutionID

		// IO holds I/O streams (Stdout, Stderr, Stdin)
		IO IOContext
		// Env holds environment configuration
		Env EnvContext
		// TUI holds TUI server connection details
		TUI TUIContext
	}

	// Result contains the result of a command execution
	Result struct {
		// ExitCode is the exit code of the command
		ExitCode ExitCode
		// Error contains any error that occurred
		Error error
		// Output contains captured stdout (if captured)
		Output string
		// ErrOutput contains captured stderr (if captured)
		ErrOutput string
	}

	// Runtime defines the interface for command execution.
	//
	// Execute may return a non-zero ExitCode without an Error — this represents a
	// normal process exit with non-zero status. Error is reserved for infrastructure
	// failures (binary not found, container failed to start, etc.). Callers should
	// check both fields: ExitCode for process-level success and Error for runtime
	// failures. Validate should be called before Execute to catch configuration
	// problems early.
	Runtime interface {
		// Name returns the runtime name
		Name() string
		// Execute runs a command in this runtime
		Execute(ctx *ExecutionContext) *Result
		// Available returns whether this runtime is available on the current system
		Available() bool
		// Validate checks if a command can be executed with this runtime
		Validate(ctx *ExecutionContext) error
	}

	// CapturingRuntime is implemented by runtimes that support capturing output.
	CapturingRuntime interface {
		// ExecuteCapture runs a command and captures stdout/stderr.
		ExecuteCapture(ctx *ExecutionContext) *Result
	}

	// InteractiveRuntime is implemented by runtimes that support interactive mode.
	// Interactive mode allows commands to be executed with PTY attachment for
	// full terminal interaction (keyboard input, terminal UI, etc.).
	InteractiveRuntime interface {
		Runtime

		// SupportsInteractive returns true if this runtime can run interactively.
		// This may depend on system configuration or the specific execution context.
		SupportsInteractive() bool

		// PrepareInteractive prepares the runtime for interactive execution.
		// The returned PreparedCommand contains an exec.Cmd that can be attached
		// to a PTY by the caller. The caller is responsible for calling the
		// Cleanup function after execution completes.
		PrepareInteractive(ctx *ExecutionContext) (*PreparedCommand, error)
	}

	// PreparedCommand contains a command ready for execution along with any cleanup function.
	// This is used by InteractiveRuntime implementations to return a command that
	// can be attached to a PTY for interactive execution.
	PreparedCommand struct {
		// Cmd is the prepared exec.Cmd ready for PTY attachment.
		Cmd *exec.Cmd
		// Cleanup is a function to call after execution (e.g., to remove temp files).
		// May be nil if no cleanup is needed.
		Cleanup func()
	}

	// RuntimeType identifies the type of runtime.
	//
	//nolint:revive // RuntimeType is more descriptive than Type for external callers
	RuntimeType string

	// InvalidRuntimeTypeError is returned when a RuntimeType value is not recognized.
	// It wraps ErrInvalidRuntimeType for errors.Is() compatibility.
	InvalidRuntimeTypeError struct {
		Value RuntimeType
	}

	// Registry holds all available runtimes and generates unique execution IDs.
	// A single Registry instance is created per command execution via
	// BuildRegistry(), so the idCounter provides execution-scoped
	// uniqueness for execution IDs. Registration should happen before any
	// concurrent calls to Get, Execute, or Available.
	Registry struct {
		runtimes  map[RuntimeType]Runtime
		idCounter atomic.Uint64
	}
)

// Error implements the error interface for InvalidRuntimeTypeError.
func (e *InvalidRuntimeTypeError) Error() string {
	return fmt.Sprintf("invalid runtime type %q (valid: native, virtual, container)", e.Value)
}

// Unwrap returns the sentinel error for errors.Is() compatibility.
func (e *InvalidRuntimeTypeError) Unwrap() error {
	return ErrInvalidRuntimeType
}

// IsValid returns whether the RuntimeType is one of the defined runtime types,
// and a list of validation errors if it is not.
func (rt RuntimeType) IsValid() (bool, []error) {
	switch rt {
	case RuntimeTypeNative, RuntimeTypeVirtual, RuntimeTypeContainer:
		return true, nil
	default:
		return false, []error{&InvalidRuntimeTypeError{Value: rt}}
	}
}

// Error implements the error interface.
func (e *InvalidExecutionIDError) Error() string {
	return fmt.Sprintf("invalid execution ID %q (must match format <nanoseconds>-<counter>)", e.Value)
}

// Unwrap returns ErrInvalidExecutionID so callers can use errors.Is for programmatic detection.
func (e *InvalidExecutionIDError) Unwrap() error { return ErrInvalidExecutionID }

// IsValid returns whether the ExecutionID matches the expected nanoseconds-counter format,
// and a list of validation errors if it does not.
func (id ExecutionID) IsValid() (bool, []error) {
	if !executionIDPattern.MatchString(string(id)) {
		return false, []error{&InvalidExecutionIDError{Value: id}}
	}
	return true, nil
}

// String returns the string representation of the ExecutionID.
func (id ExecutionID) String() string { return string(id) }

// DefaultIO returns an IOContext with standard I/O streams (os.Stdout, os.Stderr, os.Stdin).
func DefaultIO() IOContext {
	return IOContext{
		Stdout: os.Stdout,
		Stderr: os.Stderr,
		Stdin:  os.Stdin,
	}
}

// CaptureIO returns an IOContext configured to capture output, along with the
// stdout and stderr buffers for reading the captured output after execution.
func CaptureIO() (ioCtx IOContext, stdout, stderr *bytes.Buffer) {
	stdout = &bytes.Buffer{}
	stderr = &bytes.Buffer{}
	ioCtx = IOContext{
		Stdout: stdout,
		Stderr: stderr,
		Stdin:  nil,
	}
	return ioCtx, stdout, stderr
}

// DefaultEnv returns an EnvContext with an initialized ExtraEnv map.
func DefaultEnv() EnvContext {
	return EnvContext{
		ExtraEnv: make(map[string]string),
	}
}

// WithVar returns a copy of the EnvContext with the specified environment variable added.
// This is a builder-style method for fluent configuration.
func (e EnvContext) WithVar(key, value string) EnvContext {
	if e.ExtraEnv == nil {
		e.ExtraEnv = make(map[string]string)
	}
	e.ExtraEnv[key] = value
	return e
}

// IsConfigured returns true if the TUI server is configured (ServerURL is set).
func (t TUIContext) IsConfigured() bool {
	return t.ServerURL != ""
}

// NewExecutionContext creates a new execution context with the provided Go context.
// The ctx parameter is required to ensure cancellation and timeout propagation —
// passing context.Background() silently disables these features, so callers must
// provide their request-scoped context explicitly.
//
// ExecutionID is left empty; the caller should set it via Registry.NewExecutionID()
// after the registry is created (see dispatchExecution in cmd_execute.go).
// If the caller fails to set it, ContainerRuntime.prepareHostSSH generates a
// fallback ID and logs a warning (see container_exec.go).
func NewExecutionContext(ctx context.Context, cmd *invowkfile.Command, inv *invowkfile.Invowkfile) *ExecutionContext {
	currentPlatform := invowkfile.CurrentPlatform()
	defaultRuntime := cmd.GetDefaultRuntimeForPlatform(currentPlatform)
	defaultImpl := cmd.GetImplForPlatformRuntime(currentPlatform, defaultRuntime)

	return &ExecutionContext{
		Command:         cmd,
		Invowkfile:      inv,
		Context:         ctx,
		SelectedRuntime: defaultRuntime,
		SelectedImpl:    defaultImpl,
		IO:              DefaultIO(),
		Env:             DefaultEnv(),
		// TUI: zero value is fine (not configured by default)
	}
}

// EffectiveWorkDir determines the working directory using the hierarchical override model.
// Precedence (highest to lowest): CLI override > Implementation > Command > Root > Default.
// This centralizes workdir resolution that was previously duplicated across runtimes.
func (ctx *ExecutionContext) EffectiveWorkDir() string {
	return ctx.Invowkfile.GetEffectiveWorkDir(ctx.Command, ctx.SelectedImpl, ctx.WorkDir)
}

// Success returns true if the command executed successfully
func (r *Result) Success() bool {
	return r.ExitCode == 0 && r.Error == nil
}

// GetInteractiveRuntime returns the runtime as an InteractiveRuntime if it supports
// interactive mode, otherwise returns nil. This is a combined type-assertion +
// capability check: nil means either the runtime doesn't implement InteractiveRuntime
// OR SupportsInteractive() returned false (e.g., no PTY support on this system).
func GetInteractiveRuntime(rt Runtime) InteractiveRuntime {
	if ir, ok := rt.(InteractiveRuntime); ok && ir.SupportsInteractive() {
		return ir
	}
	return nil
}

// GetCapturingRuntime returns the runtime as a CapturingRuntime if it supports
// output capture, otherwise returns nil. Unlike GetInteractiveRuntime, this is
// a pure type assertion with no additional capability check.
func GetCapturingRuntime(rt Runtime) CapturingRuntime {
	if cr, ok := rt.(CapturingRuntime); ok {
		return cr
	}
	return nil
}

// NewRegistry creates a new runtime registry
func NewRegistry() *Registry {
	return &Registry{
		runtimes: make(map[RuntimeType]Runtime),
	}
}

// NewExecutionID generates a unique execution ID using a combination of the current
// nanosecond timestamp and a monotonic counter. The counter ensures uniqueness even
// when multiple IDs are generated within the same nanosecond (possible on fast CPUs
// or systems with low-precision clocks like Windows).
func (r *Registry) NewExecutionID() ExecutionID {
	return ExecutionID(fmt.Sprintf("%d-%d", time.Now().UnixNano(), r.idCounter.Add(1)))
}

// Register adds or replaces a runtime in the registry.
func (r *Registry) Register(typ RuntimeType, rt Runtime) {
	r.runtimes[typ] = rt
}

// Get returns a runtime by type
func (r *Registry) Get(typ RuntimeType) (Runtime, error) {
	rt, ok := r.runtimes[typ]
	if !ok {
		return nil, fmt.Errorf("runtime '%s' not registered: %w", typ, ErrRuntimeNotAvailable)
	}
	return rt, nil
}

// GetForContext returns the appropriate runtime based on the execution context's selected runtime
func (r *Registry) GetForContext(ctx *ExecutionContext) (Runtime, error) {
	typ := RuntimeType(ctx.SelectedRuntime)
	return r.Get(typ)
}

// Available returns all available runtimes
func (r *Registry) Available() []RuntimeType {
	var types []RuntimeType
	for typ, rt := range r.runtimes {
		if rt.Available() {
			types = append(types, typ)
		}
	}
	return types
}

// Execute runs a command using the appropriate runtime from the execution context
func (r *Registry) Execute(ctx *ExecutionContext) *Result {
	rt, err := r.GetForContext(ctx)
	if err != nil {
		return NewErrorResult(1, err)
	}

	if !rt.Available() {
		return NewErrorResult(1, fmt.Errorf("runtime '%s': %w", rt.Name(), ErrRuntimeNotAvailable))
	}

	if err := rt.Validate(ctx); err != nil {
		return NewErrorResult(1, err)
	}

	return rt.Execute(ctx)
}

// EnvToSlice converts a map of environment variables to a slice
func EnvToSlice(env map[string]string) []string {
	result := make([]string, 0, len(env))
	for k, v := range env {
		result = append(result, k+"="+v)
	}
	return result
}

// FilterInvowkEnvVars filters out Invowk-specific environment variables from the given
// environment slice. This prevents leakage of INVOWK_ARG_*, INVOWK_FLAG_*, ARGC, and ARGn
// variables when a command's script invokes another invowk command.
func FilterInvowkEnvVars(environ []string) []string {
	result := make([]string, 0, len(environ))
	for _, e := range environ {
		name, _, ok := strings.Cut(e, "=")
		if !ok {
			// Malformed env var (no '='), keep it
			result = append(result, e)
			continue
		}
		if shouldFilterEnvVar(name) {
			continue
		}
		result = append(result, e)
	}
	return result
}

// shouldFilterEnvVar returns true if the environment variable name should be filtered
// to prevent leakage between nested invowk command invocations.
func shouldFilterEnvVar(name string) bool {
	// Filter INVOWK_ARG_* and INVOWK_FLAG_* variables
	if strings.HasPrefix(name, "INVOWK_ARG_") {
		return true
	}
	if strings.HasPrefix(name, "INVOWK_FLAG_") {
		return true
	}

	// Filter metadata env vars to prevent leakage between nested invocations.
	// Each invocation gets fresh metadata from its own execution context.
	// All four vars are unconditionally filtered here, even though EnvVarSource
	// and EnvVarPlatform are conditionally injected in projectEnvVars. The
	// unconditional filtering is by design: it prevents leakage even if future
	// code paths inject these vars unconditionally.
	switch name {
	case platform.EnvVarCmdName, platform.EnvVarRuntime, platform.EnvVarSource, platform.EnvVarPlatform:
		return true
	}

	// Filter positional ARGC variable (short-form convention alongside INVOWK_ARG_*)
	if name == "ARGC" {
		return true
	}

	// Filter positional ARGn variables (ARG1, ARG2, etc. — short-form convention alongside INVOWK_ARG_*)
	if len(name) > 3 && name[:3] == "ARG" {
		// Check if the rest is all digits
		for i := 3; i < len(name); i++ {
			if name[i] < '0' || name[i] > '9' {
				return false
			}
		}
		return true
	}

	return false
}
