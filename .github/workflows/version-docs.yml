name: Version Docs

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to version docs for (e.g., v0.1.0-alpha.1)'
        required: true
        type: string

permissions:
  contents: write

# Serialize versioning runs to prevent race conditions on versions.json
concurrency:
  group: version-docs
  cancel-in-progress: false

jobs:
  version-docs:
    name: Version Documentation
    runs-on: ubuntu-latest
    steps:
      - name: Determine tag
        id: tag
        env:
          EVENT_TAG: ${{ github.event.release.tag_name }}
          DISPATCH_TAG: ${{ github.event.inputs.tag }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            TAG="$DISPATCH_TAG"
          else
            TAG="$EVENT_TAG"
          fi
          if [[ -z "$TAG" ]]; then
            echo "::error::Could not determine release tag"
            exit 1
          fi
          # Strip 'v' prefix for the version string
          VERSION="${TAG#v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Tag: $TAG, Version: $VERSION"

      # Use a GitHub App token so the push triggers deploy-website.yml.
      # Commits made with GITHUB_TOKEN do NOT trigger other workflows.
      - name: Generate App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.DOCS_APP_ID }}
          private-key: ${{ secrets.DOCS_APP_PRIVATE_KEY }}

      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: main
          token: ${{ steps.app-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: website/package-lock.json

      - name: Install dependencies
        working-directory: website
        run: npm ci

      - name: Version docs
        env:
          VERSION: ${{ steps.tag.outputs.version }}
        run: ./scripts/version-docs.sh "$VERSION"

      - name: Verify website builds
        working-directory: website
        run: npm run build

      # Create a verified commit via the GitHub GraphQL API.
      # Direct git commits on the runner are unsigned and rejected by the
      # branch protection rule "Commits must have verified signatures".
      # Commits created through the API are automatically signed by GitHub.
      - name: Commit and push
        env:
          TAG: ${{ steps.tag.outputs.tag }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git add website/
          # Exit early if no changes
          if git diff --cached --quiet; then
            echo "No documentation changes to commit."
            exit 0
          fi

          HEAD_SHA=$(git rev-parse HEAD)

          # Build additions array: non-deleted files as {path, contents (base64)}
          ADDITIONS=$(
            while IFS= read -r file; do
              jq -n --arg p "$file" --arg c "$(base64 -w 0 < "$file")" \
                '{path: $p, contents: $c}'
            done < <(git diff --cached --name-only --diff-filter=d) | jq -s '.'
          )

          # Build deletions array: deleted files as {path}
          DELETIONS=$(
            while IFS= read -r file; do
              jq -n --arg p "$file" '{path: $p}'
            done < <(git diff --cached --name-only --diff-filter=D) | jq -s '.'
          )

          # Create verified commit via GitHub API
          QUERY='
            mutation ($input: CreateCommitOnBranchInput!) {
              createCommitOnBranch(input: $input) {
                commit { oid url }
              }
            }'

          RESULT=$(jq -n \
            --arg query "$QUERY" \
            --arg repo "$GITHUB_REPOSITORY" \
            --arg headline "docs: version documentation for ${TAG}" \
            --arg oid "$HEAD_SHA" \
            --argjson additions "${ADDITIONS:-[]}" \
            --argjson deletions "${DELETIONS:-[]}" \
            '{
              query: $query,
              variables: {
                input: {
                  branch: {
                    repositoryNameWithOwner: $repo,
                    branchName: "main"
                  },
                  message: { headline: $headline },
                  fileChanges: {
                    additions: $additions,
                    deletions: $deletions
                  },
                  expectedHeadOid: $oid
                }
              }
            }' | gh api graphql --input -)

          echo "$RESULT" | jq -r '.data.createCommitOnBranch.commit | "Created commit \(.oid)\n\(.url)"'
