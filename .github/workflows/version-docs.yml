name: Version Docs

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to version docs for (e.g., v0.1.0-alpha.1)'
        required: true
        type: string

permissions:
  contents: write

# Serialize versioning runs to prevent race conditions on versions.json
concurrency:
  group: version-docs
  cancel-in-progress: false

jobs:
  version-docs:
    name: Version Documentation
    runs-on: ubuntu-latest
    steps:
      - name: Determine tag
        id: tag
        env:
          EVENT_TAG: ${{ github.event.release.tag_name }}
          DISPATCH_TAG: ${{ github.event.inputs.tag }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            TAG="$DISPATCH_TAG"
          else
            TAG="$EVENT_TAG"
          fi
          if [[ -z "$TAG" ]]; then
            echo "::error::Could not determine release tag"
            exit 1
          fi
          # Strip 'v' prefix for the version string
          VERSION="${TAG#v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Tag: $TAG, Version: $VERSION"

      # Use a GitHub App token so the push triggers deploy-website.yml.
      # Commits made with GITHUB_TOKEN do NOT trigger other workflows.
      - name: Generate App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.DOCS_APP_ID }}
          private-key: ${{ secrets.DOCS_APP_PRIVATE_KEY }}

      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: main
          token: ${{ steps.app-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: website/package-lock.json

      - name: Install dependencies
        working-directory: website
        run: npm ci

      - name: Version docs
        env:
          VERSION: ${{ steps.tag.outputs.version }}
        run: ./scripts/version-docs.sh "$VERSION"

      - name: Verify website builds
        working-directory: website
        run: npm run build

      # Create a verified commit via the GitHub GraphQL API.
      # Direct git commits on the runner are unsigned and rejected by the
      # branch protection rule "Commits must have verified signatures".
      # Commits created through the API are automatically signed by GitHub.
      - name: Commit and push
        env:
          TAG: ${{ steps.tag.outputs.tag }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git add website/
          # Exit early if no changes
          if git diff --cached --quiet; then
            echo "No documentation changes to commit."
            exit 0
          fi

          HEAD_SHA=$(git rev-parse HEAD)

          # Write additions to a temp file to avoid ARG_MAX limits.
          # Each non-deleted file becomes {path, contents (base64)}.
          # Uses --rawfile instead of --arg for the base64 content to bypass
          # Linux MAX_ARG_STRLEN (128KB per argument) which silently truncates
          # large files when passed via command-line arguments.
          ADDITIONS_FILE=$(mktemp)
          while IFS= read -r file; do
            B64_FILE=$(mktemp)
            base64 -w 0 < "$file" > "$B64_FILE"
            jq -n --arg p "$file" --rawfile c "$B64_FILE" '{path: $p, contents: $c}' || {
              echo "::error::Failed to encode file: $file"
              rm -f "$B64_FILE"
              exit 1
            }
            rm -f "$B64_FILE"
          done < <(git diff --cached --name-only --diff-filter=d) | jq -s '.' > "$ADDITIONS_FILE"

          # Validate that all staged files were encoded successfully.
          STAGED_COUNT=$(git diff --cached --name-only --diff-filter=d | wc -l)
          ENCODED_COUNT=$(jq 'length' < "$ADDITIONS_FILE")
          if [ "$STAGED_COUNT" -ne "$ENCODED_COUNT" ]; then
            echo "::error::File count mismatch: $STAGED_COUNT staged but only $ENCODED_COUNT encoded"
            exit 1
          fi

          # Write deletions to a temp file (deleted files as {path}).
          DELETIONS_FILE=$(mktemp)
          while IFS= read -r file; do
            jq -n --arg p "$file" '{path: $p}' || {
              echo "::error::Failed to process deleted file: $file"
              exit 1
            }
          done < <(git diff --cached --name-only --diff-filter=D) | jq -s '.' > "$DELETIONS_FILE"

          # Create verified commit via GitHub API.
          # --slurpfile reads from files instead of command-line args,
          # avoiding the ARG_MAX limit for large doc snapshots.
          QUERY='
            mutation ($input: CreateCommitOnBranchInput!) {
              createCommitOnBranch(input: $input) {
                commit { oid url }
              }
            }'

          RESULT=$(jq -n \
            --arg query "$QUERY" \
            --arg repo "$GITHUB_REPOSITORY" \
            --arg headline "docs: version documentation for ${TAG}" \
            --arg oid "$HEAD_SHA" \
            --slurpfile additions "$ADDITIONS_FILE" \
            --slurpfile deletions "$DELETIONS_FILE" \
            '{
              query: $query,
              variables: {
                input: {
                  branch: {
                    repositoryNameWithOwner: $repo,
                    branchName: "main"
                  },
                  message: { headline: $headline },
                  fileChanges: {
                    additions: $additions[0],
                    deletions: $deletions[0]
                  },
                  expectedHeadOid: $oid
                }
              }
            }' | gh api graphql --input -)

          rm -f "$ADDITIONS_FILE" "$DELETIONS_FILE"
          echo "$RESULT" | jq -r '.data.createCommitOnBranch.commit | "Created commit \(.oid)\n\(.url)"'
