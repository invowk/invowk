---
sidebar_position: 4
---

import Snippet from '@site/src/components/Snippet';

# Runtime Container

O runtime **container** executa comandos dentro de um container Docker ou Podman. Ele fornece isolamento completo e reprodutibilidade - seu comando executa no exato mesmo ambiente toda vez.

## Como Funciona

Quando você executa um comando com o runtime container, o Invowk:

1. Baixa ou constrói a imagem do container (se necessário)
2. Monta o diretório atual dentro do container
3. Executa o script dentro do container
4. Transmite a saída de volta para seu terminal

## Uso Básico

<Snippet id="runtime-modes/container-basic" />

```bash
invowk cmd myproject build
```

## Fontes de Imagem de Container

Você deve especificar ou uma `image` ou um `containerfile` - eles são mutuamente exclusivos.

### Imagens Pré-construídas

```cue
runtimes: [{
    name: "container"
    image: "golang:1.21"
}]
```

Imagens comuns:
- `alpine:latest` - Linux mínimo
- `ubuntu:22.04` - Ubuntu completo
- `golang:1.21` - Desenvolvimento Go
- `node:20` - Desenvolvimento Node.js
- `python:3.11` - Desenvolvimento Python

### Containerfile Personalizado

Construa a partir de um Containerfile/Dockerfile local:

<Snippet id="runtime-modes/container-containerfile" />

Exemplo de `Containerfile`:

<Snippet id="runtime-modes/containerfile-example" />

## Montagem de Volumes

Monte diretórios adicionais no container:

```cue
runtimes: [{
    name: "container"
    image: "golang:1.21"
    volumes: [
        "./data:/data",           // Caminho relativo
        "/tmp:/tmp:ro",           // Caminho absoluto, somente leitura
        "${HOME}/.cache:/cache"   // Variável de ambiente
    ]
}]
```

O diretório de trabalho atual é automaticamente montado em `/workspace`.

## Mapeamento de Portas

Exponha portas do container para o host:

<Snippet id="runtime-modes/container-ports" />

## Usando Interpretadores

Como o runtime native, containers suportam interpretadores personalizados:

### Auto-Detecção pelo Shebang

```cue
{
    name: "analyze"
    implementations: [{
        script: """
            #!/usr/bin/env python3
            import sys
            print(f"Python {sys.version} in container!")
            """
        target: {
            runtimes: [{
                name: "container"
                image: "python:3.11"
            }]
        }
    }]
}
```

### Interpretador Explícito

<Snippet id="runtime-modes/container-interpreter" />

## Variáveis de Ambiente

Variáveis de ambiente são passadas para o container:

```cue
{
    name: "deploy"
    env: {
        vars: {
            DEPLOY_ENV: "production"
            API_URL: "https://api.example.com"
        }
    }
    implementations: [{
        script: """
            echo "Deploying to $DEPLOY_ENV"
            echo "API: $API_URL"
            """
        target: {
            runtimes: [{
                name: "container"
                image: "alpine:latest"
            }]
        }
    }]
}
```

## Acesso SSH ao Host

Às vezes seu container precisa executar comandos no sistema host. Habilite acesso SSH de volta ao host:

<Snippet id="runtime-modes/container-ssh-example" />

### Variáveis de Ambiente SSH

Quando `enable_host_ssh: true`, estas variáveis estão disponíveis:

| Variável | Descrição |
|----------|-----------|
| `INVOWK_SSH_HOST` | Endereço do host (ex: `host.docker.internal`) |
| `INVOWK_SSH_PORT` | Porta do servidor SSH |
| `INVOWK_SSH_USER` | Nome de usuário (`invowk`) |
| `INVOWK_SSH_TOKEN` | Token de autenticação único |

### Segurança

- Cada execução de comando recebe um token único
- Tokens são revogados quando o comando termina
- O servidor SSH apenas aceita autenticação baseada em token
- O servidor é encerrado após a execução do comando

### Requisitos do Container

Seu container precisa de `sshpass` ou similar para SSH baseado em senha:

```dockerfile
FROM alpine:latest
RUN apk add --no-cache openssh-client sshpass
```

## Dependências

Dependências de container são validadas **dentro do container**:

```cue
{
    name: "build"
    depends_on: {
        tools: [
            // Verificadas dentro do container, não no host
            {alternatives: ["go"]},
            {alternatives: ["make"]}
        ]
        filepaths: [
            // Caminhos relativos ao /workspace do container
            {alternatives: ["go.mod"]}
        ]
    }
    implementations: [{
        script: "make build"
        target: {
            runtimes: [{
                name: "container"
                image: "golang:1.21"
            }]
        }
    }]
}
```

## Engine de Container

O Invowk suporta tanto Docker quanto Podman. Configure sua preferência:

```cue
// ~/.config/invowk/config.cue
container_engine: "podman"  // ou "docker"
```

Se não configurado, o Invowk tenta:
1. `podman` (se disponível)
2. `docker` (fallback)

## Diretório de Trabalho

Por padrão, o diretório atual é montado em `/workspace` e usado como diretório de trabalho:

```cue
{
    name: "build"
    implementations: [{
        script: """
            pwd  # Saída: /workspace
            ls   # Mostra os arquivos do seu projeto
            """
        target: {
            runtimes: [{
                name: "container"
                image: "alpine:latest"
            }]
        }
    }]
}
```

Sobrescreva com `workdir`:

```cue
{
    name: "build frontend"
    workdir: "./frontend"  // Montado e usado como workdir
    implementations: [{
        script: "npm run build"
        target: {
            runtimes: [{
                name: "container"
                image: "node:20"
            }]
        }
    }]
}
```

## Exemplo Completo

Aqui está um comando container com todos os recursos:

<Snippet id="runtime-modes/container-full-example" />

## Vantagens

- **Reprodutibilidade**: Mesmo ambiente em todos os lugares
- **Isolamento**: Sem poluição do sistema host
- **Controle de versão**: Fixe versões exatas de ferramentas
- **Paridade CI/CD**: Builds locais correspondem aos builds do CI
- **Builds limpos**: Ambiente novo cada vez

## Limitações

- **Performance**: Overhead de inicialização do container
- **Espaço em disco**: Imagens consomem armazenamento
- **Complexidade**: Necessário gerenciar imagens
- **Acesso ao host**: Limitado sem ponte SSH

## Quando Usar Container

- **Builds reproduzíveis**: Quando consistência importa
- **Pipelines CI/CD**: Corresponder ambientes local e CI
- **Projetos legados**: Isolar versões antigas de ferramentas
- **Onboarding de equipe**: Sem necessidade de instalação local de ferramentas
- **Builds em ambiente limpo**: Testar sem poluição do host

## Solução de Problemas

### Container Não Inicia

```bash
# Verificar se engine de container está disponível
docker --version  # ou: podman --version

# Verificar se imagem existe
docker images | grep golang
```

### Primeira Execução Lenta

A primeira execução baixa a imagem. Execuções subsequentes são mais rápidas:

```bash
# Pré-baixar imagens
docker pull golang:1.21
docker pull node:20
```

### Problemas de Permissão

No Linux, você pode precisar configurar permissões do container:

```bash
# Para Docker
sudo usermod -aG docker $USER

# Para Podman (rootless)
# Geralmente funciona sem configuração
```

## Próximos Passos

- [Runtime Native](./native) - Para velocidade de desenvolvimento
- [Runtime Virtual](./virtual) - Para scripts multiplataforma
- [Dependências](../dependencies/overview) - Declarar requisitos do comando
